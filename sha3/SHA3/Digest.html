<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>class SHA3::Digest - SHA3</title>

  <meta name="keywords" content="ruby,class,SHA3::Digest">

    <meta name="description" content="class SHA3::Digest: Class class, which provides a framework for creating and manipulating hash digests.">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
  <div id="parent-class-section" class="nav-section">
  <h3>Ancestors</h3>
  <ul><li>SHA3::Digest::Class</li></ul>
</div>

  
  
  
  <div class="nav-section">
    <h3>Class Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-c-new">new</a></li>
    </ul>
  </div>



  <div class="nav-section">
    <h3>Instance Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-i-3C-3C">&lt;&lt;</a></li>
      <li ><a href="#method-i-block_length">block_length</a></li>
      <li ><a href="#method-i-digest">digest</a></li>
      <li ><a href="#method-i-digest_length">digest_length</a></li>
      <li ><a href="#method-i-finish">finish</a></li>
      <li ><a href="#method-i-hex_squeeze">hex_squeeze</a></li>
      <li ><a href="#method-i-hexdigest">hexdigest</a></li>
      <li ><a href="#method-i-initialize_copy">initialize_copy</a></li>
      <li ><a href="#method-i-name">name</a></li>
      <li ><a href="#method-i-reset">reset</a></li>
      <li ><a href="#method-i-squeeze">squeeze</a></li>
      <li ><a href="#method-i-update">update</a></li>
    </ul>
  </div>



  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.12.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-labelledby="class-SHA3::Digest">
  <h1 id="class-SHA3::Digest" class="anchor-link class">
    class SHA3::Digest
  </h1>

  <section class="description">
    
<p>It is a subclass of the Digest::Class class, which provides a framework for creating and manipulating hash digests.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section anchor-link">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    ::new() &rarr; instance
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    ::new([algorithm], [message]) &rarr; instance
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="new-source">
            <pre>static VALUE rb_digest_init(int argc, VALUE* argv, VALUE self) {
    MDX* mdx;
    VALUE hlen, data;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;hlen, &amp;data);
    get_mdx(self, &amp;mdx);

    if (NIL_P(hlen)) {
        mdx-&gt;algorithm = SHA3_256;
        mdx-&gt;hashbitlen = 256;
    } else {
        mdx-&gt;hashbitlen = get_hlen(hlen, &amp;mdx-&gt;algorithm);
    }

    if (keccak_hash_initialize(mdx) != KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to initialize algorithm state&quot;);
    }

    if (!NIL_P(data)) {
        return rb_digest_update(self, data);
    }

    return self;
}</pre>
          </div>
          <p>Creates a new digest object.</p>
<dl class="rdoc-list note-list"><dt><code>algorithm</code></dt>
<dd>
<p><em>optional</em> The algorithm to use. Valid algorithms are:</p>
<ul><li>
<p>:sha3_224</p>
</li><li>
<p>:sha3_256</p>
</li><li>
<p>:sha3_384</p>
</li><li>
<p>:sha3_512</p>
</li><li>
<p>:shake_128</p>
</li><li>
<p>:shake_256</p>
</li></ul>
</dd><dt><code>message</code></dt>
<dd>
<p><em>optional</em> The message to hash.</p>
</dd></dl>

<h1 id="method-c-new-label-example">example<span><a href="#method-c-new-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-constant">SHA3</span><span class="ruby-operator">::</span><span class="ruby-constant">Digest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:sha3_256</span>)
<span class="ruby-constant">SHA3</span><span class="ruby-operator">::</span><span class="ruby-constant">Digest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:shake_128</span>, <span class="ruby-string">&quot;initial data&quot;</span>)
</pre>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-3C-3C" class="method-detail anchor-link method-alias">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-i-3C-3C" title="Link to this method">
                <span class="method-name">&lt;&lt;</span>
              </a>
            </div>
        </div>




        <div class="aliases">
          Alias for: <a href="Digest.html#method-i-update">update</a>
        </div>
      </div>

      <div id="method-i-block_length" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-block_length" title="Link to this method">
                  <span class="method-callseq">
                    block_length &rarr; Integer
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="block_length-source">
            <pre>static VALUE rb_digest_block_length(VALUE self) {
    MDX* mdx;
    get_mdx(self, &amp;mdx);

    return ULL2NUM(200 - (2 * (mdx-&gt;hashbitlen / 8)));
}</pre>
          </div>
          <p>Returns the block length of the algorithm in bytes.</p>

<h1 id="method-i-block_length-label-example">example<span><a href="#method-i-block_length-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">block_length</span>
</pre>
        </div>


      </div>

      <div id="method-i-digest" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-digest" title="Link to this method">
                  <span class="method-callseq">
                    digest() &rarr; string
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-digest" title="Link to this method">
                  <span class="method-callseq">
                    digest([data]) &rarr; string
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-digest" title="Link to this method">
                  <span class="method-callseq">
                    digest(length) &rarr; string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="digest-source">
            <pre>static VALUE rb_digest_digest(int argc, VALUE* argv, VALUE self) {
    MDX* mdx;
    VALUE length;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;length);
    get_mdx(self, &amp;mdx);

    // For SHAKE algorithms
    if (mdx-&gt;algorithm == SHAKE_128 || mdx-&gt;algorithm == SHAKE_256) {
        if (NIL_P(length)) {
            rb_raise(digest_error_class, &quot;output length must be specified for SHAKE algorithms&quot;);
        }
        return rb_digest_squeeze(self, length);
    }

    // For SHA3 algorithms, call the parent implementation
    return rb_call_super(argc, argv);
}</pre>
          </div>
          <p>Returns the binary representation of the digest.</p>
<dl class="rdoc-list note-list"><dt><code>length</code></dt>
<dd>
<p><em>optional</em> The length of the output to squeeze when using SHAKE algorithms. This parameter is required for SHAKE algorithms.</p>
</dd><dt><code>data</code></dt>
<dd>
<p><em>optional</em> Update state with additional data before returning digest.</p>
</dd></dl>

<h1 id="method-i-digest-label-example">example<span><a href="#method-i-digest-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">digest</span>()
<span class="ruby-identifier">digest</span>.<span class="ruby-identifier">digest</span>(<span class="ruby-string">&#39;compute me&#39;</span>)
<span class="ruby-identifier">digest</span>.<span class="ruby-identifier">digest</span>(<span class="ruby-value">12</span>)  <span class="ruby-comment"># For SHAKE algorithms</span>
</pre>
        </div>


      </div>

      <div id="method-i-digest_length" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-digest_length" title="Link to this method">
                  <span class="method-callseq">
                    length &rarr; Integer
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="digest_length-source">
            <pre>static VALUE rb_digest_length(VALUE self) {
    MDX* mdx;
    get_mdx(self, &amp;mdx);

    return ULL2NUM(mdx-&gt;hashbitlen / 8);
}</pre>
          </div>
          <p>Returns the length of the digest in bytes.</p>

<h1 id="method-i-digest_length-label-example">example<span><a href="#method-i-digest_length-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">length</span>  <span class="ruby-comment">#=&gt; 32 for SHA3-256</span>
</pre>
        </div>


      </div>

      <div id="method-i-hex_squeeze" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-hex_squeeze" title="Link to this method">
                  <span class="method-callseq">
                    hex_squeeze(length) &rarr; String
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="hex_squeeze-source">
            <pre>static VALUE rb_digest_hex_squeeze(VALUE self, VALUE length) {
    VALUE bin_str, result_array;

    // Get the binary output using the existing squeeze function
    bin_str = rb_digest_squeeze(self, length);

    // Use Ruby&#39;s built-in unpack method to convert to hex
    result_array = rb_funcall(bin_str, rb_intern(&quot;unpack&quot;), 1, rb_str_new2(&quot;H*&quot;));

    // Extract the first element from the array
    return rb_ary_entry(result_array, 0);
}</pre>
          </div>
          <p>Returns the hexadecimal representation of the squeezed output. Only available for SHAKE algorithms.</p>
<dl class="rdoc-list note-list"><dt><code>length</code></dt>
<dd>
<p>The length in bytes of the output to squeeze.</p>
</dd></dl>

<h1 id="method-i-hex_squeeze-label-example">example<span><a href="#method-i-hex_squeeze-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">hex_squeeze</span>(<span class="ruby-value">32</span>)  <span class="ruby-comment"># Get 64 hex characters (32 bytes)</span>
</pre>
        </div>


      </div>

      <div id="method-i-hexdigest" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-hexdigest" title="Link to this method">
                  <span class="method-callseq">
                    hexdigest() &rarr; string
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-hexdigest" title="Link to this method">
                  <span class="method-callseq">
                    hexdigest([data]) &rarr; string
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-hexdigest" title="Link to this method">
                  <span class="method-callseq">
                    hexdigest(length) &rarr; string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="hexdigest-source">
            <pre>static VALUE rb_digest_hexdigest(int argc, VALUE* argv, VALUE self) {
    MDX* mdx;
    VALUE length;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;length);
    get_mdx(self, &amp;mdx);

    // For SHAKE algorithms
    if (mdx-&gt;algorithm == SHAKE_128 || mdx-&gt;algorithm == SHAKE_256) {
        if (NIL_P(length)) {
            rb_raise(digest_error_class, &quot;output length must be specified for SHAKE algorithms&quot;);
        }
        return rb_digest_hex_squeeze(self, length);
    }

    // For SHA3 algorithms, call the parent implementation
    return rb_call_super(argc, argv);
}</pre>
          </div>
          <p>Returns the hexadecimal representation of the digest.</p>
<dl class="rdoc-list note-list"><dt><code>length</code></dt>
<dd>
<p><em>optional</em> The length of the output to squeeze when using SHAKE algorithms. This parameter is required for SHAKE algorithms.</p>
</dd><dt><code>data</code></dt>
<dd>
<p><em>optional</em> Update state with additional data before returing digest.</p>
</dd></dl>

<h1 id="method-i-hexdigest-label-example">example<span><a href="#method-i-hexdigest-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">hexdigest</span>()
<span class="ruby-identifier">digest</span>.<span class="ruby-identifier">hexdigest</span>(<span class="ruby-string">&#39;compute me&#39;</span>)
<span class="ruby-identifier">digest</span>.<span class="ruby-identifier">hexdigest</span>(<span class="ruby-value">12</span>)
</pre>
        </div>


      </div>

      <div id="method-i-initialize_copy" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-initialize_copy" title="Link to this method">
                  <span class="method-callseq">
                    initialize_copy(other) &rarr; digest
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE rb_digest_copy(VALUE self, VALUE obj) {
    MDX *mdx1, *mdx2;

    rb_check_frozen(self);
    if (self == obj) {
        return self;
    }

    get_mdx(self, &amp;mdx1);
    safe_get_mdx(obj, &amp;mdx2);

    memcpy(mdx1-&gt;state, mdx2-&gt;state, sizeof(Keccak_HashInstance));
    mdx1-&gt;hashbitlen = mdx2-&gt;hashbitlen;
    mdx1-&gt;algorithm = mdx2-&gt;algorithm;

    if (!cmp_states(mdx1, mdx2)) {
        rb_raise(digest_error_class, &quot;failed to copy state&quot;);
    }

    return self;
}</pre>
          </div>
          <p>Initializes the digest with the state of another digest.</p>
<dl class="rdoc-list note-list"><dt><code>other</code></dt>
<dd>
<p>The digest to copy the state from.</p>
</dd></dl>

<h1 id="method-i-initialize_copy-label-example">example<span><a href="#method-i-initialize_copy-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">new_digest</span> = <span class="ruby-identifier">digest</span>.<span class="ruby-identifier">dup</span>
</pre>
        </div>


      </div>

      <div id="method-i-name" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-name" title="Link to this method">
                  <span class="method-callseq">
                    name &rarr; String
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="name-source">
            <pre>static VALUE rb_digest_name(VALUE self) {
    MDX* mdx;
    get_mdx(self, &amp;mdx);

    switch (mdx-&gt;algorithm) {
        case SHA3_224:
            return rb_str_new2(&quot;SHA3-224&quot;);
        case SHA3_256:
            return rb_str_new2(&quot;SHA3-256&quot;);
        case SHA3_384:
            return rb_str_new2(&quot;SHA3-384&quot;);
        case SHA3_512:
            return rb_str_new2(&quot;SHA3-512&quot;);
        case SHAKE_128:
            return rb_str_new2(&quot;SHAKE128&quot;);
        case SHAKE_256:
            return rb_str_new2(&quot;SHAKE256&quot;);
        default:
            rb_raise(digest_error_class, &quot;unknown algorithm&quot;);
    }
}</pre>
          </div>
          <p>Returns the name of the algorithm.</p>

<h1 id="method-i-name-label-example">example<span><a href="#method-i-name-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">name</span>  <span class="ruby-comment">#=&gt; &quot;SHA3-256&quot;</span>
</pre>
        </div>


      </div>

      <div id="method-i-reset" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reset" title="Link to this method">
                  <span class="method-callseq">
                    reset &rarr; digest
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reset-source">
            <pre>static VALUE rb_digest_reset(VALUE self) {
    MDX* mdx;
    get_mdx(self, &amp;mdx);

    memset(mdx-&gt;state, 0, sizeof(Keccak_HashInstance));

    if (keccak_hash_initialize(mdx) != KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to reset internal state&quot;);
    }

    return self;
}</pre>
          </div>
          <p>Resets the digest to its initial state.</p>

<h1 id="method-i-reset-label-example">example<span><a href="#method-i-reset-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">reset</span>
</pre>
        </div>


      </div>

      <div id="method-i-squeeze" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-squeeze" title="Link to this method">
                  <span class="method-callseq">
                    squeeze(length) &rarr; String
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="squeeze-source">
            <pre>static VALUE rb_digest_squeeze(VALUE self, VALUE length) {
    MDX* mdx;
    VALUE str, copy;
    int output_bytes;

    Check_Type(length, T_FIXNUM);
    output_bytes = NUM2INT(length);

    if (output_bytes &lt;= 0) {
        rb_raise(digest_error_class, &quot;output length must be positive&quot;);
    }

    get_mdx(self, &amp;mdx);

    // Only SHAKE algorithms support arbitrary-length output
    if (mdx-&gt;algorithm != SHAKE_128 &amp;&amp; mdx-&gt;algorithm != SHAKE_256) {
        rb_raise(digest_error_class, &quot;squeeze is only supported for SHAKE algorithms&quot;);
    }

    // Create a copy of the digest object to avoid modifying the original
    copy = rb_obj_clone(self);

    // Get the MDX struct from the copy
    MDX* mdx_copy;
    get_mdx(copy, &amp;mdx_copy);

    str = rb_str_new(0, output_bytes);

    // Finalize the hash on the copy
    if (Keccak_HashFinal(mdx_copy-&gt;state, NULL) != KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to finalize digest&quot;);
    }

    // Then squeeze out the desired number of bytes
    if (Keccak_HashSqueeze(mdx_copy-&gt;state, (BitSequence*)RSTRING_PTR(str), output_bytes * 8) !=
        KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to squeeze output&quot;);
    }

    // NOTE: We don&#39;t need the copy anymore...Ruby&#39;s GC will handle freeing it

    return str;
}</pre>
          </div>
          <p>Returns the squeezed output as a binary string. Only available for SHAKE algorithms.</p>
<dl class="rdoc-list note-list"><dt><code>length</code></dt>
<dd>
<p>The length in bytes of the output to squeeze.</p>
</dd></dl>

<h1 id="method-i-squeeze-label-example">example<span><a href="#method-i-squeeze-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-value">32</span>)  <span class="ruby-comment"># Get 32 bytes of output</span>
</pre>
        </div>


      </div>

      <div id="method-i-update" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-update" title="Link to this method">
                  <span class="method-callseq">
                    update(string) &rarr; digest
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="update-source">
            <pre>static VALUE rb_digest_update(VALUE self, VALUE data) {
    MDX* mdx;
    BitLength dlen;

    StringValue(data);
    get_mdx(self, &amp;mdx);

    // Check for empty data
    if (RSTRING_LEN(data) == 0) {
        return self;
    }

    // Check for NULL data pointer
    if (RSTRING_PTR(data) == NULL) {
        rb_raise(digest_error_class, &quot;cannot update with NULL data&quot;);
    }

    dlen = (RSTRING_LEN(data) * 8);

    if (Keccak_HashUpdate(mdx-&gt;state, (BitSequence*)RSTRING_PTR(data), dlen) != KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to update hash data&quot;);
    }

    return self;
}</pre>
          </div>
          <p>Updates the digest with the given string.</p>
<dl class="rdoc-list note-list"><dt><code>string</code></dt>
<dd>
<p>The string to update the digest with.</p>
</dd></dl>

<h1 id="method-i-update-label-example">example<span><a href="#method-i-update-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">update</span>(<span class="ruby-string">&quot;more data&quot;</span>)
<span class="ruby-identifier">digest</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;more data&quot;</span>  <span class="ruby-comment"># alias for update</span>
</pre>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Digest.html#method-i-3C-3C">&lt;&lt;</a>
        </div>

      </div>

    </section>

     <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

      <div id="method-i-finish" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-finish" title="Link to this method">
                  <span class="method-callseq">
                    finish([message]) &rarr; String
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="finish-source">
            <pre>static VALUE rb_digest_finish(int argc, VALUE* argv, VALUE self) {
    MDX* mdx;
    VALUE str;
    int digest_bytes;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;str);
    get_mdx(self, &amp;mdx);

    // For both SHA3 and SHAKE algorithms, use the security strength (hashbitlen)
    // as the default output length
    digest_bytes = mdx-&gt;hashbitlen / 8;

    if (NIL_P(str)) {
        str = rb_str_new(0, digest_bytes);
    } else {
        StringValue(str);
        rb_str_resize(str, digest_bytes);
    }

    if (Keccak_HashFinal(mdx-&gt;state, (BitSequence*)RSTRING_PTR(str)) != KECCAK_SUCCESS) {
        rb_raise(digest_error_class, &quot;failed to finalize digest&quot;);
    }

    return str;
}</pre>
          </div>
          <p>Returns the final digest as a binary string.</p>
<dl class="rdoc-list note-list"><dt><code>message</code></dt>
<dd>
<p><em>optional</em> Update state with additional data before finalizing.</p>
</dd></dl>

<h1 id="method-i-finish-label-example">example<span><a href="#method-i-finish-label-example">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-identifier">digest</span>.<span class="ruby-identifier">finish</span>
<span class="ruby-identifier">digest</span>.<span class="ruby-identifier">finish</span>(<span class="ruby-string">&quot;final chunk&quot;</span>)
</pre>
        </div>


      </div>

    </section>

  </section>
</main>

