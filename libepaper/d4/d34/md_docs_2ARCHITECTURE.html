<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libepaper: Architecture Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libepaper<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">A modern C++23 library for controlling Waveshare e-paper displays on Raspberry Pi</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Architecture Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md69"></a> A comprehensive technical guide to the libepaper architecture, design decisions, and implementation details.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Table of Contents</h1>
<ul>
<li>Design Philosophy</li>
<li>System Architecture</li>
<li>Component Deep Dive</li>
<li>Data Flow</li>
<li>Design Decisions</li>
<li>Hardware Interface</li>
<li>Performance Considerations</li>
<li>Error Handling Strategy</li>
<li>Testing Architecture</li>
<li>Future Extensions</li>
</ul>
<h1><a class="anchor" id="autotoc_md71"></a>
Design Philosophy</h1>
<p>The libepaper library is built on modern C++23 principles prioritizing safety, simplicity, and extensibility.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Core Principles</h2>
<ol type="1">
<li><b>Modern C++23</b>: Leverage the latest language features for safety and expressiveness<ul>
<li><code>std::expected</code> for type-safe error handling</li>
<li><code>std::span</code> for non-owning views</li>
<li>Concepts for type constraints</li>
<li>Ranges for elegant algorithms</li>
</ul>
</li>
<li><b>Composition Over Inheritance</b>: Minimize inheritance hierarchies<ul>
<li>Favor composition and dependency injection</li>
<li>Single abstract <code>Driver</code> interface as the only inheritance point</li>
<li>RAII wrappers composed into larger systems</li>
</ul>
</li>
<li><b>RAII Everywhere</b>: Automatic resource management<ul>
<li>No manual <code>new</code>/<code>delete</code></li>
<li>Resources tied to object lifetime</li>
<li>Exception-safe by design</li>
</ul>
</li>
<li><b>Type Safety</b>: Strong typing prevents errors at compile time<ul>
<li>Enums for modes, orientations, colors</li>
<li>Type-safe wrappers around raw values</li>
<li>No implicit conversions</li>
</ul>
</li>
<li><b>Zero-Cost Abstractions</b>: Modern C++ with no runtime overhead<ul>
<li>Templates and constexpr for compile-time resolution</li>
<li>Inlining for hot paths</li>
<li>Move semantics for efficient transfers</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md73"></a>
System Architecture</h1>
<h2><a class="anchor" id="autotoc_md74"></a>
High-Level Architecture</h2>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">    A[Application Layer] --&gt; B[Display API]</div>
<div class="line">    B --&gt; C[Framebuffer Management]</div>
<div class="line">    B --&gt; D[Driver Interface]</div>
<div class="line">    D --&gt; E[EPD27 Driver]</div>
<div class="line">    E --&gt; F[Hardware Device Layer]</div>
<div class="line">    F --&gt; G[libgpiod/SPIdev]</div>
<div class="line"> </div>
<div class="line">    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000</div>
<div class="line">    style B fill:#bbdefb,stroke:#1565c0,stroke-width:2px,color:#000</div>
<div class="line">    style C fill:#90caf9,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style D fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style E fill:#42a5f5,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style F fill:#1e88e5,stroke:#0d47a1,stroke-width:2px,color:#fff</div>
<div class="line">    style G fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md75"></a>
Layer Responsibilities</h2>
<p><b>Application Layer</b></p><ul>
<li>User code and business logic</li>
<li>Example: crypto dashboard, weather station</li>
<li>Uses the Display API to draw and refresh</li>
</ul>
<p><b>Display API Layer</b> (<code><a class="el" href="../../d2/da4/display_8hpp.html">display.hpp</a></code>)</p><ul>
<li>High-level drawing operations</li>
<li>Coordinate transformation (orientation)</li>
<li>Auto-sleep management</li>
<li>Error handling and validation</li>
</ul>
<p><b>Framebuffer Management</b> (<code><a class="el" href="../../d7/d1a/framebuffer_8hpp.html">framebuffer.hpp</a></code>)</p><ul>
<li>Pixel buffer storage and manipulation</li>
<li>Pixel format conversion (1-bit, 2-bit)</li>
<li>Bounds checking and clipping</li>
<li>Buffer access abstraction</li>
</ul>
<p><b>Driver Interface</b> (<code><a class="el" href="../../d7/d7e/driver_8hpp.html">drivers/driver.hpp</a></code>)</p><ul>
<li>Abstract contract for display hardware</li>
<li>Hardware-independent operations</li>
<li>Capability queries</li>
<li>Sleep/wake lifecycle</li>
</ul>
<p><b>Concrete Driver</b> (<code><a class="el" href="../../d8/d1c/epd27_8cpp.html">drivers/epd27.cpp</a></code>)</p><ul>
<li>EPD27-specific implementation</li>
<li>Command sequences and timing</li>
<li>LUT (Look-Up Table) management</li>
<li>Hardware state tracking</li>
</ul>
<p><b>Hardware Device Layer</b> (<code><a class="el" href="../../d5/d08/device_8hpp.html">device.hpp</a></code>)</p><ul>
<li>libgpiod (GPIO) and Linux SPIdev (SPI) wrapper</li>
<li>RAII resource management</li>
<li>Pin control and SPI transfers</li>
<li>Low-level hardware interface</li>
<li>User-space access (no sudo required)</li>
</ul>
<h1><a class="anchor" id="autotoc_md76"></a>
Component Deep Dive</h1>
<h2><a class="anchor" id="autotoc_md77"></a>
Device Layer: libgpiod/SPIdev Hardware Interface</h2>
<p>The <code>Device</code> class wraps libgpiod (GPIO) and Linux SPIdev (SPI) for safe hardware access.</p>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class Device {</div>
<div class="line">        -std::atomic~bool~ initialized_</div>
<div class="line">        -std::unique_ptr~Impl~ pimpl_</div>
<div class="line">        +Device()</div>
<div class="line">        +Device(config)</div>
<div class="line">        +init() expected~void, Error~</div>
<div class="line">        +cleanup() void</div>
<div class="line">        +write_pin(pin, value) void</div>
<div class="line">        +read_pin(pin) bool</div>
<div class="line">        +spi_transfer(data) void</div>
<div class="line">        +delay_ms(ms) void</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    class DeviceConfig {</div>
<div class="line">        +string gpio_chip</div>
<div class="line">        +string spi_device</div>
<div class="line">        +uint32_t spi_speed_hz</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    class Impl {</div>
<div class="line">        &lt;&lt;Private Implementation&gt;&gt;</div>
<div class="line">        -libgpiod GPIO calls</div>
<div class="line">        -Linux SPIdev SPI calls</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Device *-- Impl : contains</div>
<div class="line">    Device ..&gt; DeviceConfig : uses</div>
</div><!-- fragment --><p><b>DeviceConfig:</b> Flexible configuration for GPIO chip, SPI device, and SPI speed:</p>
<div class="fragment"><div class="line"><span class="comment">// Default configuration</span></div>
<div class="line">DeviceConfig default_config;  <span class="comment">// Uses /dev/gpiochip0, /dev/spidev0.0, 1953125 Hz</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom configuration</span></div>
<div class="line">DeviceConfig custom_config{</div>
<div class="line">    .gpio_chip = <span class="stringliteral">&quot;/dev/gpiochip0&quot;</span>,</div>
<div class="line">    .spi_device = <span class="stringliteral">&quot;/dev/spidev0.1&quot;</span>,  <span class="comment">// Different SPI bus</span></div>
<div class="line">    .spi_speed_hz = 4000000           <span class="comment">// 4 MHz</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Device device{custom_config};</div>
</div><!-- fragment --><p><b>Key Features:</b></p><ul>
<li><b>RAII</b>: Constructor/destructor manage libgpiod and SPIdev resources</li>
<li><b>Atomic State</b>: Thread-safe initialization tracking</li>
<li><b>PImpl</b>: Hide libgpiod/SPIdev details from public interface</li>
<li><b>Error Handling</b>: Returns <code>std::expected</code> for init failures</li>
<li><b>Configurable</b>: DeviceConfig allows custom GPIO/SPI paths and speeds</li>
</ul>
<p><b>Why This Design:</b></p><ul>
<li><b>Testability</b>: Can mock <code>Device</code> for unit tests</li>
<li><b>Encapsulation</b>: libgpiod/SPIdev details don't leak into headers</li>
<li><b>Resource Safety</b>: Automatic cleanup prevents resource leaks</li>
<li><b>Flexibility</b>: DeviceConfig enables different hardware setups</li>
</ul>
<h2><a class="anchor" id="autotoc_md78"></a>
Driver Interface: Hardware Abstraction</h2>
<p>The abstract <code>Driver</code> class defines the contract for display hardware.</p>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class Driver {</div>
<div class="line">        &lt;&lt;interface&gt;&gt;</div>
<div class="line">        +init(mode) expected~void, Error~*</div>
<div class="line">        +clear() expected~void, Error~*</div>
<div class="line">        +display(buffer) expected~void, Error~*</div>
<div class="line">        +sleep() expected~void, Error~*</div>
<div class="line">        +wake() expected~void, Error~*</div>
<div class="line">        +power_off() expected~void, Error~*</div>
<div class="line">        +power_on() expected~void, Error~*</div>
<div class="line">        +width() size_t*</div>
<div class="line">        +height() size_t*</div>
<div class="line">        +mode() DisplayMode*</div>
<div class="line">        +buffer_size() size_t*</div>
<div class="line">        +supports_partial_refresh() bool*</div>
<div class="line">        +supports_power_control() bool*</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    class EPD27 {</div>
<div class="line">        -Device&amp; device_</div>
<div class="line">        -DisplayMode current_mode_</div>
<div class="line">        -bool is_asleep_</div>
<div class="line">        -bool initialized_</div>
<div class="line">        +init(mode) expected~void, Error~</div>
<div class="line">        +display(buffer) expected~void, Error~</div>
<div class="line">        +sleep() expected~void, Error~</div>
<div class="line">        +wake() expected~void, Error~</div>
<div class="line">        -reset() void</div>
<div class="line">        -send_command(cmd) void</div>
<div class="line">        -wait_busy() void</div>
<div class="line">        -set_lut() void</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Driver &lt;|.. EPD27 : implements</div>
</div><!-- fragment --><p><b>Interface Segregation:</b></p><ul>
<li>Minimal required methods (pure virtual)</li>
<li>Optional capabilities via capability queries</li>
<li>No forced implementations of unsupported features</li>
</ul>
<p><b>Why Abstract Interface:</b></p><ul>
<li><b>Extensibility</b>: Easy to add new displays (4.2", 7.5", etc.)</li>
<li><b>Polymorphism</b>: <code>Display</code> class works with any driver</li>
<li><b>Testing</b>: Mock drivers for unit tests</li>
<li><b>Separation of Concerns</b>: Hardware details isolated in drivers</li>
</ul>
<h2><a class="anchor" id="autotoc_md79"></a>
Display Class: High-Level API</h2>
<p>The <code>Display</code> class provides user-facing drawing operations and manages display state.</p>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class Display {</div>
<div class="line">        -Driver&amp; driver_</div>
<div class="line">        -Framebuffer framebuffer_</div>
<div class="line">        -Orientation orientation_</div>
<div class="line">        -bool auto_sleep_enabled_</div>
<div class="line">        +line() LineBuilder</div>
<div class="line">        +rectangle() RectangleBuilder</div>
<div class="line">        +circle() CircleBuilder</div>
<div class="line">        +point() PointBuilder</div>
<div class="line">        +text(string) TextBuilder</div>
<div class="line">        +draw(LineCommand) void</div>
<div class="line">        +draw(RectangleCommand) void</div>
<div class="line">        +draw(CircleCommand) void</div>
<div class="line">        +draw(PointCommand) void</div>
<div class="line">        +draw(TextCommand) void</div>
<div class="line">        +draw_bitmap(x, y, data, w, h) void</div>
<div class="line">        +draw_bitmap_from_file(x, y, path) expected~void, Error~</div>
<div class="line">        +clear(color) void</div>
<div class="line">        +refresh() expected~void, Error~</div>
<div class="line">        +sleep() expected~void, Error~</div>
<div class="line">        +wake() expected~void, Error~</div>
<div class="line">        +effective_width() size_t</div>
<div class="line">        +effective_height() size_t</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    class Framebuffer {</div>
<div class="line">        -std::vector~std::byte~ buffer_</div>
<div class="line">        -size_t width_</div>
<div class="line">        -size_t height_</div>
<div class="line">        -DisplayMode mode_</div>
<div class="line">        +set_pixel(x, y, color) void</div>
<div class="line">        +get_pixel(x, y) Color</div>
<div class="line">        +clear(color) void</div>
<div class="line">        +data() span~byte~</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    class Orientation {</div>
<div class="line">        &lt;&lt;enumeration&gt;&gt;</div>
<div class="line">        Portrait0</div>
<div class="line">        Landscape90</div>
<div class="line">        Portrait180</div>
<div class="line">        Landscape270</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Display o-- Framebuffer : contains</div>
<div class="line">    Display --&gt; Orientation : uses</div>
<div class="line">    Display --&gt; Driver : uses</div>
</div><!-- fragment --><p><b>Coordinate Transformation:</b> The <code>Display</code> class transparently handles coordinate rotation based on <code>Orientation</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Internal coordinate transformation</span></div>
<div class="line"><span class="keyword">auto</span> transform_coordinates(<span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> y, Orientation orient) -&gt; std::pair&lt;size_t, size_t&gt; {</div>
<div class="line">  <span class="keywordflow">switch</span> (orient) {</div>
<div class="line">    <span class="keywordflow">case</span> Orientation::Portrait0:   <span class="keywordflow">return</span> {x, y};</div>
<div class="line">    <span class="keywordflow">case</span> Orientation::Landscape90: <span class="keywordflow">return</span> {height - 1 - y, x};</div>
<div class="line">    <span class="keywordflow">case</span> Orientation::Portrait180: <span class="keywordflow">return</span> {width - 1 - x, height - 1 - y};</div>
<div class="line">    <span class="keywordflow">case</span> Orientation::Landscape270: <span class="keywordflow">return</span> {y, width - 1 - x};</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Transparent Sleep/Wake Management:</b></p>
<p>The library now handles sleep/wake cycles automatically:</p>
<div class="fragment"><div class="line">stateDiagram-v2</div>
<div class="line">    [*] --&gt; Awake: init()</div>
<div class="line">    Awake --&gt; Asleep: refresh() with auto-sleep</div>
<div class="line">    Asleep --&gt; Awake: refresh() auto-wakes</div>
<div class="line">    Awake --&gt; Awake: refresh() without auto-sleep</div>
<div class="line">    Awake --&gt; [*]: destructor</div>
<div class="line">    Asleep --&gt; [*]: destructor</div>
<div class="line"> </div>
<div class="line">    note right of Asleep</div>
<div class="line">        Driver tracks state internally</div>
<div class="line">        Next refresh() auto-wakes</div>
<div class="line">        No manual wake() needed!</div>
<div class="line">    end note</div>
</div><!-- fragment --><p><b>Key Features:</b></p><ul>
<li><b>Auto-Sleep</b>: Prevents burn-in by sleeping after refresh (configurable)</li>
<li><b>Auto-Wake</b>: Transparently wakes display when rendering (EPD27 re-initializes)</li>
<li><b>State Tracking</b>: Driver maintains <code>is_asleep_</code> flag for idempotent operations</li>
<li><b>Developer Ergonomics</b>: No manual sleep/wake management needed</li>
</ul>
<h2><a class="anchor" id="autotoc_md80"></a>
Color Management</h2>
<p>The library supports both black/white and grayscale displays with a unified color system.</p>
<div class="fragment"><div class="line">graph LR</div>
<div class="line">    A[Application Color] --&gt; B{Display Mode}</div>
<div class="line">    B --&gt;|BlackWhite| C[1-bit: 0=white, 1=black]</div>
<div class="line">    B --&gt;|Grayscale4| D[2-bit: 00=white, 01=gray1, 10=gray2, 11=black]</div>
<div class="line"> </div>
<div class="line">    C --&gt; E[Framebuffer Encoding]</div>
<div class="line">    D --&gt; E</div>
<div class="line">    E --&gt; F[Hardware Buffer]</div>
<div class="line"> </div>
<div class="line">    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000</div>
<div class="line">    style B fill:#fff9c4,stroke:#f57f17,stroke-width:2px,color:#000</div>
<div class="line">    style C fill:#90caf9,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style D fill:#90caf9,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style E fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style F fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff</div>
</div><!-- fragment --><p><b>Color Enum:</b> </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> Color {</div>
<div class="line">  White,  <span class="comment">// Lightest (0)</span></div>
<div class="line">  Gray1,  <span class="comment">// Light gray (grayscale mode only)</span></div>
<div class="line">  Gray2,  <span class="comment">// Dark gray (grayscale mode only)</span></div>
<div class="line">  Black   <span class="comment">// Darkest (3)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Framebuffer Encoding:</b></p><ul>
<li><b>BlackWhite mode</b>: 1 bit per pixel, packed 8 pixels per byte</li>
<li><b>Grayscale4 mode</b>: 2 bits per pixel, packed 4 pixels per byte</li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
Automatic Color Conversion</h2>
<p>The library includes a sophisticated color management system that automatically handles color conversion from RGB/RGBA to display-appropriate formats.</p>
<p><b>ColorManager Class:</b></p>
<p>The <code>ColorManager</code> (in <code><a class="el" href="../../d6/d9f/color__manager_8hpp.html">include/epaper/color/color_manager.hpp</a></code>) provides automatic conversion:</p>
<div class="fragment"><div class="line"><span class="comment">// RGB to Grayscale conversion using standard formula</span></div>
<div class="line"><span class="keyword">auto</span> rgb_to_gray(<span class="keyword">const</span> RGB&amp; color) -&gt; uint8_t {</div>
<div class="line">  <span class="keywordflow">return</span> 0.299 * R + 0.587 * G + 0.114 * B;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Automatic quantization based on display mode</span></div>
<div class="line">BlackWhite mode:  gray &gt;= 128 ? White : Black</div>
<div class="line">Grayscale4 mode:  0-63 → Black, 64-127 → Gray2, 128-191 → Gray1, 192-255 → White</div>
</div><!-- fragment --><p><b>Image Loading with Automatic Conversion:</b></p>
<p>When you load images (PNG, JPEG, BMP, TGA, GIF, PSD, HDR), the library automatically:</p>
<ol type="1">
<li><b>Loads</b> the image using stb_image</li>
<li><b>Converts</b> RGB/RGBA to grayscale using standard luminance formula</li>
<li><b>Quantizes</b> to display's color depth (1-bit or 2-bit)</li>
<li><b>Renders</b> to framebuffer</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Load a full-color photo - automatic conversion!</span></div>
<div class="line">display-&gt;draw_bitmap_from_file(0, 0, <span class="stringliteral">&quot;colorful_photo.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Library automatically handles:</span></div>
<div class="line"><span class="comment">// 1. PNG decode → RGB</span></div>
<div class="line"><span class="comment">// 2. RGB → Grayscale (0.299*R + 0.587*G + 0.114*B)</span></div>
<div class="line"><span class="comment">// 3. Grayscale → 4-level quantization (if in Grayscale4 mode)</span></div>
<div class="line"><span class="comment">// 4. Draw to framebuffer</span></div>
</div><!-- fragment --><p><b>Benefits:</b></p><ul>
<li><b>Zero manual work</b>: Load any color image without preprocessing</li>
<li><b>Intelligent quantization</b>: Uses perceptual grayscale conversion</li>
<li><b>Format agnostic</b>: Works with PNG, JPEG, BMP, and more</li>
<li><b>Mode aware</b>: Automatically adapts to BlackWhite or Grayscale4 display mode</li>
</ul>
<p>This means developers can use standard color images and the library handles all conversion automatically.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Data Flow</h1>
<h2><a class="anchor" id="autotoc_md83"></a>
Display Refresh Flow</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App</div>
<div class="line">    participant Display</div>
<div class="line">    participant Driver</div>
<div class="line">    participant Hardware</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Display: refresh()</div>
<div class="line">    Display-&gt;&gt;Driver: display(framebuffer)</div>
<div class="line"> </div>
<div class="line">    alt Driver is asleep</div>
<div class="line">        Driver-&gt;&gt;Driver: wake() [re-init hardware]</div>
<div class="line">        Note over Driver: EPD27: ~2s re-initialization</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    Driver-&gt;&gt;Hardware: SPI transfer (command)</div>
<div class="line">    Driver-&gt;&gt;Hardware: SPI transfer (data)</div>
<div class="line">    Driver-&gt;&gt;Hardware: Wait BUSY pin</div>
<div class="line">    Hardware--&gt;&gt;Driver: Transfer complete</div>
<div class="line"> </div>
<div class="line">    alt Auto-sleep enabled</div>
<div class="line">        Driver-&gt;&gt;Driver: sleep() [deep sleep]</div>
<div class="line">        Driver-&gt;&gt;Driver: Set is_asleep_ = true</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    Driver--&gt;&gt;Display: Success</div>
<div class="line">    Display--&gt;&gt;App: Success</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md84"></a>
Drawing Operation Flow</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App</div>
<div class="line">    participant Display</div>
<div class="line">    participant Framebuffer</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Display: draw(line().from(x1,y1).to(x2,y2).color(c).build())</div>
<div class="line">    Display-&gt;&gt;Display: Transform coordinates (orientation)</div>
<div class="line">    Display-&gt;&gt;Display: Bresenham line algorithm</div>
<div class="line">    loop For each point</div>
<div class="line">        Display-&gt;&gt;Framebuffer: set_pixel(x, y, color)</div>
<div class="line">        Framebuffer-&gt;&gt;Framebuffer: Check bounds</div>
<div class="line">        Framebuffer-&gt;&gt;Framebuffer: Encode color for mode</div>
<div class="line">        Framebuffer-&gt;&gt;Framebuffer: Update buffer byte</div>
<div class="line">    end</div>
<div class="line">    Display--&gt;&gt;App: void (always succeeds)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md85"></a>
Initialization Flow</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App</div>
<div class="line">    participant Device</div>
<div class="line">    participant Driver</div>
<div class="line">    participant Display</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Device: init()</div>
<div class="line">    Device-&gt;&gt;Device: libgpiod/SPIdev initialization</div>
<div class="line">    Device-&gt;&gt;Device: SPI setup</div>
<div class="line">    Device--&gt;&gt;App: expected&lt;void, Error&gt;</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Driver: new EPD27(device)</div>
<div class="line">    App-&gt;&gt;Driver: init(DisplayMode)</div>
<div class="line">    Driver-&gt;&gt;Driver: Hardware reset</div>
<div class="line">    Driver-&gt;&gt;Driver: Send init commands</div>
<div class="line">    Driver-&gt;&gt;Driver: Load LUT</div>
<div class="line">    Driver-&gt;&gt;Driver: Set is_asleep_ = false</div>
<div class="line">    Driver--&gt;&gt;App: expected&lt;void, Error&gt;</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Display: create_display(...)</div>
<div class="line">    Display-&gt;&gt;Display: Allocate framebuffer</div>
<div class="line">    Display-&gt;&gt;Display: Setup orientation</div>
<div class="line">    Display--&gt;&gt;App: unique_ptr&lt;Display&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md86"></a>
Design Decisions</h1>
<h2><a class="anchor" id="autotoc_md87"></a>
Why &lt;tt&gt;std::expected&lt;/tt&gt; Over Exceptions?</h2>
<p><b>Decision:</b> Use <code>std::expected&lt;T, Error&gt;</code> for recoverable errors instead of exceptions.</p>
<p><b>Rationale:</b></p><ol type="1">
<li><b>Explicit Error Handling</b>: Caller must check result (no silent failures)</li>
<li><b>Performance</b>: No exception unwinding overhead in hot paths</li>
<li><b>Predictable Control Flow</b>: Clear success/error paths</li>
<li><b>Composability</b>: Monadic operations (<code>and_then</code>, <code>or_else</code>) for error chains</li>
<li><b>Resource-Constrained</b>: Better for embedded systems (Raspberry Pi)</li>
</ol>
<p><b>Trade-offs:</b></p><ul>
<li><b>Verbosity</b>: Must explicitly check each result</li>
<li><b>Learning Curve</b>: Newer C++23 feature</li>
<li><b>Benefits</b>: Type safety, performance, explicitness</li>
</ul>
<h2><a class="anchor" id="autotoc_md88"></a>
Why Transparent Sleep/Wake Management?</h2>
<p><b>Problem:</b> EPD27 hardware requires deep sleep to prevent burn-in, but doesn't support wake without full re-initialization.</p>
<p><b>Previous Approach (Manual):</b> </p><div class="fragment"><div class="line">display-&gt;refresh();  <span class="comment">// First render</span></div>
<div class="line">display-&gt;sleep();    <span class="comment">// Developer must remember!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later...</span></div>
<div class="line">display-&gt;wake();     <span class="comment">// May fail - EPD27 doesn&#39;t support wake!</span></div>
<div class="line">display-&gt;refresh();  <span class="comment">// Hangs if still asleep</span></div>
</div><!-- fragment --><p><b>New Approach (Transparent):</b> </p><div class="fragment"><div class="line">display-&gt;refresh();  <span class="comment">// First render, auto-sleeps</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later...</span></div>
<div class="line">display-&gt;refresh();  <span class="comment">// Auto-wakes if needed, just works!</span></div>
</div><!-- fragment --><p><b>Implementation:</b></p><ul>
<li>Driver maintains <code>bool is_asleep_</code> state</li>
<li><code>sleep()</code> sets flag, <code>init()</code> clears flag</li>
<li><code>display()</code> checks flag and calls <code>wake()</code> (re-init) if needed</li>
<li><code>wake()</code> is idempotent (no-op if already awake)</li>
</ul>
<p><b>Benefits:</b></p><ol type="1">
<li><b>Developer Ergonomics</b>: No manual sleep/wake management</li>
<li><b>Correctness</b>: Impossible to forget to wake</li>
<li><b>Hardware Abstraction</b>: Hide EPD27 limitation from users</li>
<li><b>Consistent API</b>: Same code works for different displays</li>
</ol>
<h2><a class="anchor" id="autotoc_md89"></a>
Why Composition Over Inheritance?</h2>
<p><b>Decision:</b> Minimize inheritance, prefer composition and dependency injection.</p>
<p><b>Example: Display Construction</b> </p><div class="fragment"><div class="line"><span class="comment">// Composition: Display receives driver by reference</span></div>
<div class="line"><span class="keyword">class </span>Display {</div>
<div class="line">  Driver&amp; driver_;           <span class="comment">// Reference to driver (dependency injection)</span></div>
<div class="line">  Framebuffer framebuffer_;  <span class="comment">// Composed framebuffer</span></div>
<div class="line">  Orientation orientation_;  <span class="comment">// Composed state</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// NOT: class Display : public Driver { }  // Inheritance would couple tightly</span></div>
</div><!-- fragment --><p><b>Benefits:</b></p><ol type="1">
<li><b>Flexibility</b>: Easily swap drivers at runtime</li>
<li><b>Testability</b>: Mock drivers for unit tests</li>
<li><b>Simplicity</b>: Flat structure, no deep hierarchies</li>
<li><b>Single Responsibility</b>: Each class has one job</li>
</ol>
<h2><a class="anchor" id="autotoc_md90"></a>
Why Abstract Driver Interface?</h2>
<p><b>Decision:</b> Single abstract <code>Driver</code> interface, not multiple interfaces.</p>
<p><b>Rationale:</b></p><ol type="1">
<li><b>Extensibility</b>: Add new displays by implementing one interface</li>
<li><b>Polymorphism</b>: <code>Display</code> works with any conforming driver</li>
<li><b>Interface Segregation</b>: Optional features via capability queries</li>
<li><b>Clear Contract</b>: Well-defined responsibilities</li>
</ol>
<p><b>Future-Proof:</b></p><ul>
<li>Can add new display sizes without changing architecture</li>
<li>Can support color displays by extending <code>Color</code> enum</li>
<li>Can add partial refresh if hardware supports it</li>
</ul>
<h2><a class="anchor" id="autotoc_md91"></a>
Memory Management Strategy</h2>
<p><b>Decision:</b> RAII for all resources, no manual <code>new</code>/<code>delete</code>.</p>
<p><b>Patterns:</b></p><ol type="1">
<li><b>std::unique_ptr</b>: For polymorphic objects (<code>create_display</code> returns <code>unique_ptr&lt;Display&gt;</code>)</li>
<li><b>std::vector</b>: For dynamic buffers (framebuffer storage)</li>
<li><b>std::span</b>: For non-owning views (buffer passing to driver)</li>
<li><b>References</b>: For composition (driver reference in Display)</li>
<li><b>Value Semantics</b>: For small objects (Color, Orientation enums)</li>
</ol>
<p><b>Benefits:</b></p><ul>
<li><b>Exception Safety</b>: Resources freed even on exception</li>
<li><b>No Leaks</b>: Impossible to forget to free</li>
<li><b>Move Semantics</b>: Efficient transfers without copying</li>
</ul>
<h1><a class="anchor" id="autotoc_md92"></a>
Hardware Interface</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
SPI Communication Protocol</h2>
<p>The e-paper display uses SPI for communication with a command/data distinction.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant CPU</div>
<div class="line">    participant GPIO</div>
<div class="line">    participant SPI</div>
<div class="line">    participant Display</div>
<div class="line"> </div>
<div class="line">    CPU-&gt;&gt;GPIO: Set DC = LOW (command mode)</div>
<div class="line">    CPU-&gt;&gt;GPIO: Set CS = LOW (select device)</div>
<div class="line">    CPU-&gt;&gt;SPI: Transfer command byte</div>
<div class="line">    SPI--&gt;&gt;Display: Command byte</div>
<div class="line">    CPU-&gt;&gt;GPIO: Set CS = HIGH (deselect)</div>
<div class="line"> </div>
<div class="line">    CPU-&gt;&gt;GPIO: Set DC = HIGH (data mode)</div>
<div class="line">    CPU-&gt;&gt;GPIO: Set CS = LOW (select device)</div>
<div class="line">    CPU-&gt;&gt;SPI: Transfer data bytes</div>
<div class="line">    SPI--&gt;&gt;Display: Data bytes</div>
<div class="line">    CPU-&gt;&gt;GPIO: Set CS = HIGH (deselect)</div>
<div class="line"> </div>
<div class="line">    CPU-&gt;&gt;GPIO: Read BUSY pin</div>
<div class="line">    alt BUSY == HIGH</div>
<div class="line">        CPU-&gt;&gt;CPU: Wait (polling)</div>
<div class="line">    end</div>
</div><!-- fragment --><p><b>Pin Roles:</b></p><ul>
<li><b>DC (Data/Command)</b>: LOW = command, HIGH = data</li>
<li><b>CS (Chip Select)</b>: LOW = device selected, HIGH = device idle</li>
<li><b>RST (Reset)</b>: LOW = reset, HIGH = normal operation</li>
<li><b>BUSY</b>: HIGH = display busy, LOW = ready for commands</li>
</ul>
<h2><a class="anchor" id="autotoc_md94"></a>
EPD27 Command Set</h2>
<p>Key commands used by the EPD27 driver:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">Hex   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DRIVER_OUTPUT_CONTROL   </td><td class="markdownTableBodyNone">0x01   </td><td class="markdownTableBodyNone">Set scanning parameters    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BOOSTER_SOFT_START   </td><td class="markdownTableBodyNone">0x0C   </td><td class="markdownTableBodyNone">Configure booster    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GATE_SCAN_START   </td><td class="markdownTableBodyNone">0x0F   </td><td class="markdownTableBodyNone">Set gate scan start position    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">DEEP_SLEEP_MODE   </td><td class="markdownTableBodyNone">0x10   </td><td class="markdownTableBodyNone">Enter deep sleep    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DATA_ENTRY_MODE   </td><td class="markdownTableBodyNone">0x11   </td><td class="markdownTableBodyNone">Set data entry sequence    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SW_RESET   </td><td class="markdownTableBodyNone">0x12   </td><td class="markdownTableBodyNone">Software reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TEMPERATURE_SENSOR   </td><td class="markdownTableBodyNone">0x1A   </td><td class="markdownTableBodyNone">Read temperature sensor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MASTER_ACTIVATION   </td><td class="markdownTableBodyNone">0x20   </td><td class="markdownTableBodyNone">Activate display update    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DISPLAY_UPDATE_CONTROL   </td><td class="markdownTableBodyNone">0x21   </td><td class="markdownTableBodyNone">Configure update sequence    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WRITE_RAM   </td><td class="markdownTableBodyNone">0x24   </td><td class="markdownTableBodyNone">Write framebuffer to RAM    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">WRITE_VCOM_REGISTER   </td><td class="markdownTableBodyNone">0x2C   </td><td class="markdownTableBodyNone">Set VCOM voltage    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WRITE_LUT_REGISTER   </td><td class="markdownTableBodyNone">0x32   </td><td class="markdownTableBodyNone">Load look-up table    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SET_RAM_X   </td><td class="markdownTableBodyNone">0x44   </td><td class="markdownTableBodyNone">Set RAM X address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SET_RAM_Y   </td><td class="markdownTableBodyNone">0x45   </td><td class="markdownTableBodyNone">Set RAM Y address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SET_RAM_X_COUNTER   </td><td class="markdownTableBodyNone">0x4E   </td><td class="markdownTableBodyNone">Set RAM X counter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SET_RAM_Y_COUNTER   </td><td class="markdownTableBodyNone">0x4F   </td><td class="markdownTableBodyNone">Set RAM Y counter   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md95"></a>
Initialization Sequence</h2>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">    A[Start] --&gt; B[Hardware Reset]</div>
<div class="line">    B --&gt; C[Software Reset]</div>
<div class="line">    C --&gt; D[Wait BUSY]</div>
<div class="line">    D --&gt; E[Set Driver Output]</div>
<div class="line">    E --&gt; F[Set Data Entry Mode]</div>
<div class="line">    F --&gt; G[Set RAM Boundaries]</div>
<div class="line">    G --&gt; H[Set Display Update Control]</div>
<div class="line">    H --&gt; I[Load LUT]</div>
<div class="line">    I --&gt; J[Set VCOM]</div>
<div class="line">    J --&gt; K[Set Temperature Sensor]</div>
<div class="line">    K --&gt; L[Master Activation]</div>
<div class="line">    L --&gt; M[Wait BUSY]</div>
<div class="line">    M --&gt; N[Ready]</div>
<div class="line"> </div>
<div class="line">    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000</div>
<div class="line">    style N fill:#66bb6a,stroke:#2e7d32,stroke-width:2px,color:#fff</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md96"></a>
Pin Configuration</h2>
<p>Default Raspberry Pi GPIO pin assignments:</p>
<div class="fragment"><div class="line">graph LR</div>
<div class="line">    subgraph &quot;Raspberry Pi GPIO&quot;</div>
<div class="line">        RST[GPIO 17 - RST]</div>
<div class="line">        DC[GPIO 25 - DC]</div>
<div class="line">        CS[GPIO 8 - CS/CE0]</div>
<div class="line">        BUSY[GPIO 24 - BUSY]</div>
<div class="line">        MOSI[GPIO 10 - MOSI]</div>
<div class="line">        SCLK[GPIO 11 - SCLK]</div>
<div class="line">        GND[GND]</div>
<div class="line">        VCC[3.3V]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;E-Paper Display&quot;</div>
<div class="line">        ERST[RST]</div>
<div class="line">        EDC[DC]</div>
<div class="line">        ECS[CS]</div>
<div class="line">        EBUSY[BUSY]</div>
<div class="line">        EMOSI[DIN]</div>
<div class="line">        ESCLK[CLK]</div>
<div class="line">        EGND[GND]</div>
<div class="line">        EVCC[VCC]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    RST --&gt; ERST</div>
<div class="line">    DC --&gt; EDC</div>
<div class="line">    CS --&gt; ECS</div>
<div class="line">    BUSY --&gt; EBUSY</div>
<div class="line">    MOSI --&gt; EMOSI</div>
<div class="line">    SCLK --&gt; ESCLK</div>
<div class="line">    GND --&gt; EGND</div>
<div class="line">    VCC --&gt; EVCC</div>
<div class="line"> </div>
<div class="line">    style RST fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style DC fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style CS fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style BUSY fill:#64b5f6,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style MOSI fill:#42a5f5,stroke:#0d47a1,stroke-width:2px,color:#000</div>
<div class="line">    style SCLK fill:#42a5f5,stroke:#0d47a1,stroke-width:2px,color:#000</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md97"></a>
Performance Considerations</h1>
<h2><a class="anchor" id="autotoc_md98"></a>
Framebuffer Size</h2>
<p>Memory footprint varies by display mode:</p>
<p><b>2.7" Display (176x264 pixels = 46,464 pixels):&lt;/strong&gt;
- &lt;strong&gt;Black/White mode&lt;/strong&gt;: 5,808 bytes (46,464 bits / 8)
- &lt;strong&gt;Grayscale4 mode&lt;/strong&gt;: 11,616 bytes (46,464 * 2 bits / 8)

&lt;strong&gt;Larger Displays (hypothetical 4.2" - 400x300 = 120,000 pixels):</b></p><ul>
<li><b>Black/White mode</b>: 15,000 bytes</li>
<li><b>Grayscale4 mode</b>: 30,000 bytes</li>
</ul>
<h2><a class="anchor" id="autotoc_md99"></a>
Refresh Times</h2>
<p>Approximate refresh times for EPD27:</p>
<ul>
<li><b>Full Refresh</b>: ~2 seconds (hardware limitation)</li>
<li><b>Wake from Sleep</b>: ~2 seconds (requires full re-initialization)</li>
<li><b>Partial Refresh</b>: Not supported by EPD27 hardware</li>
</ul>
<p><b>Optimization Tips:</b></p><ul>
<li>Batch drawing operations before calling <code>refresh()</code></li>
<li>Minimize <code>refresh()</code> calls (e.g., 5-second intervals for live data)</li>
<li>Use auto-sleep to protect hardware between refreshes</li>
</ul>
<h2><a class="anchor" id="autotoc_md100"></a>
SPI Transfer Rates</h2>
<p>The Linux SPIdev operates at configurable speeds:</p><ul>
<li><b>Current</b>: ~1.95 MHz (250MHz / 128, equivalent to previous BCM2835 CLOCK_DIVIDER_128)</li>
<li><b>Maximum</b>: 32 MHz (may cause errors with long wires)</li>
</ul>
<p><b>Framebuffer Transfer Time:</b></p><ul>
<li>At ~1.95 MHz: ~24ms for 5,808 bytes (black/white mode)</li>
<li>Negligible compared to display refresh time (~2s)</li>
</ul>
<h1><a class="anchor" id="autotoc_md101"></a>
Error Handling Strategy</h1>
<h2><a class="anchor" id="autotoc_md102"></a>
Error Types</h2>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> ErrorCode {</div>
<div class="line">  <span class="comment">// Device errors (hardware layer)</span></div>
<div class="line">  DeviceNotInitialized,</div>
<div class="line">  DeviceInitFailed,</div>
<div class="line">  SPIInitFailed,</div>
<div class="line">  InvalidPin,</div>
<div class="line">  TransferFailed,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Driver errors (display layer)</span></div>
<div class="line">  DriverNotInitialized,</div>
<div class="line">  DriverInitFailed,</div>
<div class="line">  InvalidDisplayMode,</div>
<div class="line">  HardwareTimeout,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display errors (API layer)</span></div>
<div class="line">  DisplayNotReady,</div>
<div class="line">  RefreshFailed,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// File I/O errors</span></div>
<div class="line">  FileNotFound,</div>
<div class="line">  InvalidFormat,</div>
<div class="line">  LoadFailed</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Error {</div>
<div class="line">  ErrorCode code;</div>
<div class="line">  std::string message;  <span class="comment">// Optional context</span></div>
<div class="line">  <span class="keyword">auto</span> what() const -&gt; std::string_view;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Recovery Strategies</h2>
<p><b>1. Initialization Errors:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = device.init();</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">  <span class="comment">// Fatal - cannot proceed</span></div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Hardware init failed: &quot;</span> &lt;&lt; result.error().what() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. Transient Errors:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = display-&gt;refresh();</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">  <span class="comment">// Retry with exponential backoff</span></div>
<div class="line">  std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">  result = display-&gt;refresh();  <span class="comment">// Retry</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>3. Benign Errors:</b> </p><div class="fragment"><div class="line"><span class="comment">// Drawing operations never fail - out of bounds is clipped</span></div>
<div class="line">display-&gt;draw(display-&gt;point().at(1000, 1000).color(Color::Black).build());  <span class="comment">// Safely ignored</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md104"></a>
Testing Architecture</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
Test Organization</h2>
<div class="fragment"><div class="line">tests/</div>
<div class="line">├── test_auto_sleep.cpp          # Auto-sleep behavior</div>
<div class="line">├── test_bitmaps.cpp             # Bitmap drawing</div>
<div class="line">├── test_coordinate_transforms.cpp  # Orientation transforms</div>
<div class="line">├── test_display_modes.cpp       # Black/white vs grayscale</div>
<div class="line">├── test_drawing_primitives.cpp  # Lines, circles, etc.</div>
<div class="line">├── test_edge_cases.cpp          # Boundary conditions</div>
<div class="line">├── test_error_handling.cpp      # Error propagation</div>
<div class="line">├── test_fonts.cpp               # Font rendering</div>
<div class="line">├── test_orientations.cpp        # Display rotation</div>
<div class="line">├── test_power_management.cpp    # Sleep/wake cycles</div>
<div class="line">└── test_stress.cpp              # Performance &amp; stability</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md106"></a>
Hardware Mocking Strategy</h2>
<p>For CI/CD and unit tests without Raspberry Pi hardware:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MockDevice : <span class="keyword">public</span> Device {</div>
<div class="line">  <span class="comment">// Stub implementations for testing</span></div>
<div class="line">  <span class="keyword">auto</span> init() -&gt; std::expected&lt;void, Error&gt; <span class="keyword">override</span> {</div>
<div class="line">    <span class="keywordflow">return</span> {};  <span class="comment">// Always succeed</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> spi_transfer(std::span&lt;const std::byte&gt; data) -&gt; <span class="keywordtype">void</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// Record call for verification</span></div>
<div class="line">    spi_calls_.push_back({data.begin(), data.end()});</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::vector&lt;std::byte&gt;&gt; spi_calls_;  <span class="comment">// For assertions</span></div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md107"></a>
Future Extensions</h1>
<h2><a class="anchor" id="autotoc_md108"></a>
Partial Refresh Support</h2>
<p>Some e-paper displays support partial refresh (faster updates of screen regions).</p>
<p><b>Requirements:</b></p><ul>
<li>Hardware support (EPD27 doesn't support this)</li>
<li>Driver capability query: <code>supports_partial_refresh()</code></li>
<li>New API: <code>refresh_region(x, y, width, height)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md109"></a>
Color Display Support</h2>
<p>Adding red/yellow e-paper displays would require:</p>
<p><b>1. Extend Color Enum:</b> </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> Color {</div>
<div class="line">  White, Black,  <span class="comment">// Monochrome</span></div>
<div class="line">  Gray1, Gray2,  <span class="comment">// Grayscale</span></div>
<div class="line">  Red, Yellow    <span class="comment">// Color displays (NEW)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>2. Update Framebuffer Encoding:</b></p><ul>
<li>3 bits per pixel for 8 colors</li>
<li>Separate red/black buffers (some displays use this)</li>
</ul>
<p><b>3. Driver Implementation:</b></p><ul>
<li>Two-pass display update (black, then color)</li>
<li>Color-specific LUTs</li>
</ul>
<h2><a class="anchor" id="autotoc_md110"></a>
Additional Display Drivers</h2>
<p><b>Easy to Add:</b></p><ul>
<li>1.54" displays (200x200)
- 4.2" displays (400x300)</li>
<li>7.5" displays (800x480)

&lt;strong&gt;Process:&lt;/strong&gt;
1. Implement &lt;tt&gt;Driver&lt;/tt&gt; interface
2. Add initialization sequence from datasheet
3. Add driver-specific commands
4. Write tests
5. Done! All existing APIs work automatically.

&lt;hr&gt;

&lt;strong&gt;For driver development details, see @ref "/mnt/nas/libepaper/docs/DRIVER.md" "<a class="el" href="../../de/d79/DRIVER_8md.html">DRIVER.md</a>".&lt;/strong&gt;
&lt;strong&gt;For API usage, see @ref "/mnt/nas/libepaper/docs/API.md" "<a class="el" href="../../d7/d7a/API_8md.html">API.md</a>". </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
