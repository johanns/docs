<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libepaper: Driver Development Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libepaper<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">A modern C++23 library for controlling Waveshare e-paper displays on Raspberry Pi</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Driver Development Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md120"></a> A comprehensive guide to writing custom display drivers for libepaper.</p>
<h1><a class="anchor" id="autotoc_md121"></a>
Table of Contents</h1>
<ul>
<li>Overview</li>
<li>Driver Interface</li>
<li>Step-by-Step: Writing a Driver</li>
<li>EPD27 as Reference</li>
<li>Hardware Integration</li>
<li>Display Modes</li>
<li>State Management</li>
<li>Error Handling in Drivers</li>
<li>Testing Your Driver</li>
<li>Optimization Tips</li>
<li>Implementation Checklist</li>
<li>Common Issues &amp; Solutions</li>
<li>Contributing Your Driver</li>
</ul>
<h1><a class="anchor" id="autotoc_md122"></a>
Overview</h1>
<h2><a class="anchor" id="autotoc_md123"></a>
What is a Driver?</h2>
<p>A driver is a concrete implementation of the abstract <code>Driver</code> interface that:</p><ul>
<li>Communicates with specific e-paper display hardware</li>
<li>Translates generic operations into hardware-specific commands</li>
<li>Manages display initialization, sleep/wake cycles, and power control</li>
<li>Handles timing, busy waiting, and hardware state</li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
When to Write a New Driver</h2>
<p>Write a new driver when you want to support:</p><ul>
<li>A different e-paper display size (1.54", 4.2", 7.5", etc.)
- A different manufacturer's displays
- Displays with different capabilities (partial refresh, color, faster refresh)

@subsection autotoc_md125 Architecture

@icode 
Application Code
       ↓
Display API (display.hpp)
       ↓
Driver Interface (driver.hpp) ← Abstract contract
       ↓
Your Driver (your_epd.cpp) ← Implement this!
       ↓
Hardware Device (device.hpp)
       ↓
BCM2835/SPI/GPIO
@endicode 

@section autotoc_md126 Driver Interface

@subsection autotoc_md127 Required Methods

All drivers must implement the pure virtual methods of the &lt;tt&gt;Driver&lt;/tt&gt; interface:

@icode{cpp} 
// include/epaper/drivers/driver.hpp
class Driver {
public:
  virtual ~Driver() = default;

  // Lifecycle
  virtual auto init(DisplayMode mode) -&gt; std::expected&lt;void, Error&gt; = 0;
  virtual auto clear() -&gt; std::expected&lt;void, Error&gt; = 0;
  virtual auto display(std::span&lt;const std::byte&gt; buffer) -&gt; std::expected&lt;void, Error&gt; = 0;

  // Power management
  virtual auto sleep() -&gt; std::expected&lt;void, Error&gt; = 0;
  virtual auto wake() -&gt; std::expected&lt;void, Error&gt; = 0;
  virtual auto power_off() -&gt; std::expected&lt;void, Error&gt; = 0;
  virtual auto power_on() -&gt; std::expected&lt;void, Error&gt; = 0;

  // Capabilities
  [[nodiscard]] virtual auto width() const noexcept -&gt; std::size_t = 0;
  [[nodiscard]] virtual auto height() const noexcept -&gt; std::size_t = 0;
  [[nodiscard]] virtual auto mode() const noexcept -&gt; DisplayMode = 0;
  [[nodiscard]] virtual auto buffer_size() const noexcept -&gt; std::size_t = 0;
  [[nodiscard]] virtual auto supports_partial_refresh() const noexcept -&gt; bool = 0;
  [[nodiscard]] virtual auto supports_power_control() const noexcept -&gt; bool = 0;
};
@endicode 

@subsection autotoc_md128 Method Responsibilities

**&lt;tt&gt;init(DisplayMode mode)&lt;/tt&gt;**
- Initialize display hardware
- Load appropriate LUT (Look-Up Table) for mode
- Set up display parameters
- Must be called before other operations
- Returns error if hardware communication fails

**&lt;tt&gt;clear()&lt;/tt&gt;**
- Clear display to white (or default background)
- Send clear command to hardware
- Usually calls &lt;tt&gt;wait_busy()&lt;/tt&gt; internally

**&lt;tt&gt;display(std::span\&lt;const std::byte\&gt; buffer)&lt;/tt&gt;**
- Transfer framebuffer to display RAM
- Trigger display update
- &lt;strong&gt;Important:&lt;/strong&gt; For transparent sleep/wake, check if asleep and call &lt;tt&gt;wake()&lt;/tt&gt; if needed
- Block until update completes

**&lt;tt&gt;sleep()&lt;/tt&gt;**
- Put display into low-power sleep mode
- Set &lt;tt&gt;is_asleep_&lt;/tt&gt; flag to true
- Should be idempotent (safe to call when already asleep)

**&lt;tt&gt;wake()&lt;/tt&gt;**
- Wake display from sleep
- For EPD27: requires full re-initialization (~2 seconds)
- Set &lt;tt&gt;is_asleep_&lt;/tt&gt; flag to false
- Should be idempotent (safe to call when already awake)

**&lt;tt&gt;power_off()&lt;/tt&gt; / &lt;tt&gt;power_on()&lt;/tt&gt;**
- Complete power control (if supported)
- Return error if not supported by hardware

&lt;strong&gt;Capability Queries:&lt;/strong&gt;
- &lt;tt&gt;width()&lt;/tt&gt;, &lt;tt&gt;height()&lt;/tt&gt;: Physical display dimensions
- &lt;tt&gt;mode()&lt;/tt&gt;: Current display mode
- &lt;tt&gt;buffer_size()&lt;/tt&gt;: Required framebuffer size in bytes
- &lt;tt&gt;supports_partial_refresh()&lt;/tt&gt;: Can do partial screen updates?
- &lt;tt&gt;supports_power_control()&lt;/tt&gt;: Has power control pins?

@section autotoc_md129 Step-by-Step: Writing a Driver

@subsection autotoc_md130 Step 1: Hardware Analysis

Before writing code, study the display datasheet:

&lt;strong&gt;Key Information to Extract:&lt;/strong&gt;
1. &lt;strong&gt;Dimensions&lt;/strong&gt;: Width and height in pixels
2. &lt;strong&gt;Command Set&lt;/strong&gt;: List of commands and their hex codes
3. &lt;strong&gt;Initialization Sequence&lt;/strong&gt;: Commands to initialize display
4. &lt;strong&gt;LUT Requirements&lt;/strong&gt;: Look-up tables for grayscale/refresh modes
5. &lt;strong&gt;Timing&lt;/strong&gt;: Delays needed between commands
6. &lt;strong&gt;Power Control&lt;/strong&gt;: Sleep/wake procedures
7. &lt;strong&gt;Busy Pin Behavior&lt;/strong&gt;: How to detect ready state

&lt;strong&gt;Example: EPD27 Datasheet Analysis&lt;/strong&gt;
- Dimensions: 176×264 pixels
- Commands: &lt;tt&gt;0x10&lt;/tt&gt; (sleep), &lt;tt&gt;0x12&lt;/tt&gt; (reset), &lt;tt&gt;0x20&lt;/tt&gt; (activate), etc.
- Initialization: 12-step sequence with specific delays
- LUT: 30-byte table for grayscale mode
- Busy pin: HIGH = busy, LOW = ready

@subsection autotoc_md131 Step 2: Header File

Create a header in &lt;tt&gt;include/epaper/drivers/&lt;/tt&gt;:

@icode{cpp} 
// include/epaper/drivers/epd42.hpp (example for 4.2" display) #pragma once</li>
</ul>
<p>#include &lt;<a class="el" href="../../d7/d7e/driver_8hpp.html">epaper/drivers/driver.hpp</a>&gt; #include &lt;<a class="el" href="../../d5/d08/device_8hpp.html">epaper/device.hpp</a>&gt; #include &lt;<a class="el" href="../../d2/da4/display_8hpp.html">epaper/display.hpp</a>&gt; #include &lt;<a class="el" href="../../df/d52/errors_8hpp.html">epaper/errors.hpp</a>&gt; #include &lt;cstddef&gt; #include &lt;expected&gt;</p>
<p>namespace epaper {</p>
<p>class EPD42 : public Driver { public: // Display dimensions (from datasheet) static constexpr std::size_t WIDTH = 400; static constexpr std::size_t HEIGHT = 300;</p>
<p>explicit EPD42(Device&amp; device); ~EPD42() override = default;</p>
<p>// Lifecycle auto init(DisplayMode mode) -&gt; std::expected&lt;void, Error&gt; override; auto clear() -&gt; std::expected&lt;void, Error&gt; override; auto display(std::span&lt;const std::byte&gt; buffer) -&gt; std::expected&lt;void, Error&gt; override;</p>
<p>// Power management auto sleep() -&gt; std::expected&lt;void, Error&gt; override; auto wake() -&gt; std::expected&lt;void, Error&gt; override; auto power_off() -&gt; std::expected&lt;void, Error&gt; override; auto power_on() -&gt; std::expected&lt;void, Error&gt; override;</p>
<p>// Capabilities [[nodiscard]] auto width() const noexcept -&gt; std::size_t override { return WIDTH; } [[nodiscard]] auto height() const noexcept -&gt; std::size_t override { return HEIGHT; } [[nodiscard]] auto mode() const noexcept -&gt; DisplayMode override { return current_mode_; } [[nodiscard]] auto buffer_size() const noexcept -&gt; std::size_t override; [[nodiscard]] auto supports_partial_refresh() const noexcept -&gt; bool override { return false; } [[nodiscard]] auto supports_power_control() const noexcept -&gt; bool override { return false; }</p>
<p>private: // Hardware communication auto reset() -&gt; void; auto send_command(std::uint8_t command) -&gt; void; auto send_data(std::uint8_t data) -&gt; void; auto send_data(std::span&lt;const std::uint8_t&gt; data) -&gt; void; auto wait_busy() -&gt; void;</p>
<p>// Display-specific auto set_lut_bw() -&gt; void; auto set_lut_gray() -&gt; void; auto set_memory_area(std::uint16_t x_start, std::uint16_t y_start,
                       std::uint16_t x_end, std::uint16_t y_end) -&gt; void; auto set_memory_pointer(std::uint16_t x, std::uint16_t y) -&gt; void;</p>
<p>// State Device&amp; device_; DisplayMode current_mode_; bool initialized_ = false; bool is_asleep_ = false; // Track sleep state for transparent wake };</p>
<p>} // namespace epaper </p>
<h2><a class="anchor" id="autotoc_md132"></a>
Step 3: Initialization Sequence</h2>
<p>Implement the <code>init()</code> method with the hardware initialization sequence:</p>
<div class="fragment"><div class="line"><span class="comment">// src/drivers/epd42.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;epaper/drivers/epd42.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="../../db/da4/namespaceepaper.html">epaper</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">  <span class="comment">// Command definitions (from datasheet)</span></div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">SW_RESET</a> = 0x12;</div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">DRIVER_OUTPUT_CONTROL</a> = 0x01;</div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">DATA_ENTRY_MODE</a> = 0x11;</div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">DISPLAY_UPDATE_CONTROL</a> = 0x21;</div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">MASTER_ACTIVATION</a> = 0x20;</div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">WRITE_LUT</a> = 0x32;</div>
<div class="line">  <span class="comment">// ... more commands ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">EPD42::EPD42(Device&amp; <a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">device</a>) : device_(<a class="code hl_function" href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">device</a>) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> EPD42::init(DisplayMode mode) -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  current_mode_ = mode;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Hardware reset</span></div>
<div class="line">  reset();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Software reset</span></div>
<div class="line">  send_command(SW_RESET);</div>
<div class="line">  wait_busy();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Driver output control (from datasheet)</span></div>
<div class="line">  send_command(DRIVER_OUTPUT_CONTROL);</div>
<div class="line">  send_data((HEIGHT - 1) &amp; 0xFF);        <span class="comment">// Y pixels low byte</span></div>
<div class="line">  send_data(((HEIGHT - 1) &gt;&gt; 8) &amp; 0xFF); <span class="comment">// Y pixels high byte</span></div>
<div class="line">  send_data(0x00);                       <span class="comment">// GD = 0, SM = 0, TB = 0</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Data entry mode (X increment, Y increment)</span></div>
<div class="line">  send_command(DATA_ENTRY_MODE);</div>
<div class="line">  send_data(0x03);  <span class="comment">// Increment X and Y</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set RAM area (full screen)</span></div>
<div class="line">  set_memory_area(0, 0, WIDTH - 1, HEIGHT - 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set RAM pointer to origin</span></div>
<div class="line">  set_memory_pointer(0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Load LUT based on mode</span></div>
<div class="line">  <span class="keywordflow">if</span> (mode == DisplayMode::Grayscale4) {</div>
<div class="line">    set_lut_gray();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    set_lut_bw();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Display update control</span></div>
<div class="line">  send_command(DISPLAY_UPDATE_CONTROL);</div>
<div class="line">  send_data(0xC7);  <span class="comment">// Enable clock, enable analog, display mode 1, disable OSC</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Master activation (required before first display update)</span></div>
<div class="line">  send_command(MASTER_ACTIVATION);</div>
<div class="line">  wait_busy();</div>
<div class="line"> </div>
<div class="line">  initialized_ = <span class="keyword">true</span>;</div>
<div class="line">  is_asleep_ = <span class="keyword">false</span>;  <span class="comment">// Awake after init</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace epaper</span></div>
<div class="ttc" id="anamespaceepaper_html"><div class="ttname"><a href="../../db/da4/namespaceepaper.html">epaper</a></div><div class="ttdef"><b>Definition</b> color.hpp:5</div></div>
<div class="ttc" id="anamespaceepaper_html_ae87c16acc02a64356214d15caff24201"><div class="ttname"><a href="../../db/da4/namespaceepaper.html#ae87c16acc02a64356214d15caff24201">epaper::create_display</a></div><div class="ttdeci">auto create_display(Device &amp;device, DisplayMode mode, Orientation orientation=Orientation::Portrait0, bool auto_sleep=true) -&gt; std::expected&lt; Display, Error &gt;</div><div class="ttdef"><b>Definition</b> display.hpp:597</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
Step 4: Display Buffer Transfer</h2>
<p>Implement the <code>display()</code> method with <b>transparent wake support</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> EPD42::display(std::span&lt;const std::byte&gt; buffer) -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="keywordflow">if</span> (!initialized_) {</div>
<div class="line">    <span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::DriverNotInitialized,</div>
<div class="line">                                 <span class="stringliteral">&quot;EPD42 not initialized&quot;</span>});</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// IMPORTANT: Transparent wake management</span></div>
<div class="line">  <span class="keywordflow">if</span> (is_asleep_) {</div>
<div class="line">    <span class="keyword">auto</span> wake_result = wake();  <span class="comment">// Re-initialize if asleep</span></div>
<div class="line">    <span class="keywordflow">if</span> (!wake_result) {</div>
<div class="line">      <span class="keywordflow">return</span> wake_result;  <span class="comment">// Propagate error</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::size_t expected_size = buffer_size();</div>
<div class="line">  <span class="keywordflow">if</span> (buffer.size() != expected_size) {</div>
<div class="line">    <span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::InvalidDimensions,</div>
<div class="line">                                 <span class="stringliteral">&quot;Buffer size mismatch&quot;</span>});</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set memory pointer to origin</span></div>
<div class="line">  set_memory_pointer(0, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Write buffer to display RAM</span></div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t WRITE_RAM = 0x24;</div>
<div class="line">  send_command(WRITE_RAM);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Transfer buffer in chunks (SPI limitation)</span></div>
<div class="line">  <span class="keyword">constexpr</span> std::size_t CHUNK_SIZE = 4096;</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; buffer.size(); i += CHUNK_SIZE) {</div>
<div class="line">    std::size_t chunk_size = std::min(CHUNK_SIZE, buffer.size() - i);</div>
<div class="line">    <span class="keyword">auto</span> chunk = buffer.subspan(i, chunk_size);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert std::byte to uint8_t for send_data</span></div>
<div class="line">    std::vector&lt;std::uint8_t&gt; data(chunk_size);</div>
<div class="line">    std::transform(chunk.begin(), chunk.end(), data.begin(),</div>
<div class="line">                  [](std::byte b) { return static_cast&lt;std::uint8_t&gt;(b); });</div>
<div class="line">    send_data(data);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Trigger display update</span></div>
<div class="line">  send_command(MASTER_ACTIVATION);</div>
<div class="line">  wait_busy();  <span class="comment">// Block until complete (~2 seconds)</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md134"></a>
Step 5: Power Management</h2>
<p>Implement sleep/wake with proper state tracking:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> EPD42::sleep() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="comment">// Idempotent: safe to call when already asleep</span></div>
<div class="line">  <span class="keywordflow">if</span> (is_asleep_) {</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> std::uint8_t DEEP_SLEEP_MODE = 0x10;</div>
<div class="line">  send_command(DEEP_SLEEP_MODE);</div>
<div class="line">  send_data(0x01);  <span class="comment">// Enter deep sleep mode</span></div>
<div class="line"> </div>
<div class="line">  is_asleep_ = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> EPD42::wake() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="comment">// Idempotent: safe to call when already awake</span></div>
<div class="line">  <span class="keywordflow">if</span> (!is_asleep_) {</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// EPD42 (like EPD27) requires full re-initialization after deep sleep</span></div>
<div class="line">  <span class="keyword">auto</span> result = init(current_mode_);</div>
<div class="line">  <span class="keywordflow">if</span> (!result) {</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  is_asleep_ = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> EPD42::power_off() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="comment">// Not supported by this hardware</span></div>
<div class="line">  <span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::UnsupportedOperation,</div>
<div class="line">                               <span class="stringliteral">&quot;EPD42 does not support power_off&quot;</span>});</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> EPD42::power_on() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="comment">// Not supported by this hardware</span></div>
<div class="line">  <span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::UnsupportedOperation,</div>
<div class="line">                               <span class="stringliteral">&quot;EPD42 does not support power_on&quot;</span>});</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md135"></a>
Step 6: Testing</h2>
<p>Write tests to validate your driver (see Testing Your Driver).</p>
<h1><a class="anchor" id="autotoc_md136"></a>
EPD27 as Reference</h1>
<p>The <code>EPD27</code> driver is the canonical reference implementation. Study it for patterns:</p>
<h2><a class="anchor" id="autotoc_md137"></a>
Key Patterns from EPD27</h2>
<p><b>1. Hardware Reset:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> EPD27::reset() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  device_.write_pin(pins::RST, <span class="keyword">true</span>);</div>
<div class="line">  device_.delay_ms(200);</div>
<div class="line">  device_.write_pin(pins::RST, <span class="keyword">false</span>);</div>
<div class="line">  device_.delay_ms(2);</div>
<div class="line">  device_.write_pin(pins::RST, <span class="keyword">true</span>);</div>
<div class="line">  device_.delay_ms(200);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. Command/Data Sending:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> EPD27::send_command(std::uint8_t command) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  device_.write_pin(pins::DC, <span class="keyword">false</span>);  <span class="comment">// DC LOW = command</span></div>
<div class="line">  device_.spi_transfer(std::span{<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::byte*<span class="keyword">&gt;</span>(&amp;command), 1});</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> EPD27::send_data(std::uint8_t data) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  device_.write_pin(pins::DC, <span class="keyword">true</span>);   <span class="comment">// DC HIGH = data</span></div>
<div class="line">  device_.spi_transfer(std::span{<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::byte*<span class="keyword">&gt;</span>(&amp;data), 1});</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>3. Busy Waiting:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> EPD27::wait_busy() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  <span class="comment">// EPD27 BUSY pin: HIGH = busy, LOW = ready</span></div>
<div class="line">  <span class="keywordflow">while</span> (device_.read_pin(pins::BUSY)) {</div>
<div class="line">    device_.delay_ms(10);  <span class="comment">// Poll every 10ms</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>4. LUT Loading:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> EPD27::set_lut() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  <span class="comment">// 30-byte Look-Up Table for grayscale waveforms</span></div>
<div class="line">  <span class="keyword">constexpr</span> std::array&lt;std::uint8_t, 30&gt; lut_full = {</div>
<div class="line">    0x02, 0x02, 0x01, 0x11, 0x12, 0x12, 0x22, 0x22,</div>
<div class="line">    0x66, 0x69, 0x69, 0x59, 0x58, 0x99, 0x99, 0x88,</div>
<div class="line">    <span class="comment">// ... rest of LUT ...</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  send_command(WRITE_LUT_REGISTER);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">byte</span> : lut_full) {</div>
<div class="line">    send_data(<span class="keywordtype">byte</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md138"></a>
EPD27 State Management</h2>
<p>Study how EPD27 implements transparent wake:</p>
<div class="fragment"><div class="line"><span class="comment">// In display() method:</span></div>
<div class="line"><span class="keywordflow">if</span> (is_asleep_) {</div>
<div class="line">  <span class="keyword">auto</span> wake_result = wake();</div>
<div class="line">  <span class="keywordflow">if</span> (!wake_result) {</div>
<div class="line">    <span class="keywordflow">return</span> wake_result;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ... proceed with display update ...</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md139"></a>
Hardware Integration</h1>
<h2><a class="anchor" id="autotoc_md140"></a>
SPI Communication</h2>
<p>Use the <code>Device</code> class for all hardware access:</p>
<div class="fragment"><div class="line"><span class="comment">// GPIO pin control</span></div>
<div class="line">device_.write_pin(pins::RST, <span class="keyword">true</span>);   <span class="comment">// Set RST HIGH</span></div>
<div class="line">device_.write_pin(pins::DC, <span class="keyword">false</span>);   <span class="comment">// Set DC LOW</span></div>
<div class="line"><span class="keywordtype">bool</span> busy = device_.read_pin(pins::BUSY);  <span class="comment">// Read BUSY pin</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// SPI transfer</span></div>
<div class="line">std::array&lt;std::byte, 4&gt; data = {std::byte{0x01}, std::byte{0x02}, ...};</div>
<div class="line">device_.spi_transfer(data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Delays</span></div>
<div class="line">device_.delay_ms(100);  <span class="comment">// Wait 100ms</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md141"></a>
Pin Usage</h2>
<p>Standard e-paper pins:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Pin   </th><th class="markdownTableHeadNone">Direction   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RST   </td><td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">Hardware reset (LOW to reset)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">DC   </td><td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">Data/Command select (LOW = command, HIGH = data)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CS   </td><td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">Chip select (handled by SPI library)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BUSY   </td><td class="markdownTableBodyNone">Input   </td><td class="markdownTableBodyNone">Status (HIGH = busy, LOW = ready)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MOSI   </td><td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">SPI data out (handled by SPI library)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SCLK   </td><td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">SPI clock (handled by SPI library)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md142"></a>
Command/Data Protocol</h2>
<div class="fragment"><div class="line"><span class="comment">// Send command</span></div>
<div class="line"><span class="keywordtype">void</span> send_command(uint8_t cmd) {</div>
<div class="line">  device_.write_pin(pins::DC, <span class="keyword">false</span>);  <span class="comment">// Command mode</span></div>
<div class="line">  device_.spi_transfer(span of cmd);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send data</span></div>
<div class="line"><span class="keywordtype">void</span> send_data(uint8_t data) {</div>
<div class="line">  device_.write_pin(pins::DC, <span class="keyword">true</span>);   <span class="comment">// Data mode</span></div>
<div class="line">  device_.spi_transfer(span of data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typical command sequence</span></div>
<div class="line">send_command(SOME_COMMAND);</div>
<div class="line">send_data(param1);</div>
<div class="line">send_data(param2);</div>
<div class="line">wait_busy();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md143"></a>
Display Modes</h1>
<h2><a class="anchor" id="autotoc_md144"></a>
Implementing Black/White Mode</h2>
<p><b>Buffer Format:</b> 1 bit per pixel, 8 pixels per byte</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> EPD42::buffer_size() const noexcept -&gt; std::<span class="keywordtype">size_t</span> {</div>
<div class="line">  <span class="keywordflow">if</span> (current_mode_ == DisplayMode::BlackWhite) {</div>
<div class="line">    <span class="comment">// 1 bit per pixel: (width * height) / 8</span></div>
<div class="line">    <span class="keywordflow">return</span> (WIDTH * HEIGHT) / 8;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Grayscale4: 2 bits per pixel: (width * height) / 4</span></div>
<div class="line">    <span class="keywordflow">return</span> (WIDTH * HEIGHT) / 4;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Pixel Encoding:</b></p><ul>
<li>Bit = 0: White pixel</li>
<li>Bit = 1: Black pixel</li>
</ul>
<p><b>Byte Packing (MSB first):</b> </p><div class="fragment"><div class="line">Byte: [P7 P6 P5 P4 P3 P2 P1 P0]</div>
<div class="line">P0 = leftmost pixel</div>
<div class="line">P7 = rightmost pixel</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md145"></a>
Implementing Grayscale4 Mode</h2>
<p><b>Buffer Format:</b> 2 bits per pixel, 4 pixels per byte</p>
<p><b>Pixel Encoding:</b></p><ul>
<li><code>00</code>: White (0)</li>
<li><code>01</code>: Light gray (1)</li>
<li><code>10</code>: Dark gray (2)</li>
<li><code>11</code>: Black (3)</li>
</ul>
<p><b>LUT Requirements:</b> Grayscale mode requires a Look-Up Table (LUT) that defines voltage waveforms for each gray level. Consult your display's datasheet for the correct LUT values.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> EPD42::set_lut_gray() -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">  <span class="keyword">constexpr</span> std::array&lt;std::uint8_t, 30&gt; lut_gray = {</div>
<div class="line">    <span class="comment">// Voltage waveforms for 4-level grayscale (from datasheet)</span></div>
<div class="line">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</div>
<div class="line">    <span class="comment">// ... (values specific to your display)</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  send_command(WRITE_LUT);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">byte</span> : lut_gray) {</div>
<div class="line">    send_data(<span class="keywordtype">byte</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md146"></a>
State Management</h1>
<h2><a class="anchor" id="autotoc_md147"></a>
Required State Variables</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>YourDriver : <span class="keyword">public</span> Driver {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Device&amp; device_;           <span class="comment">// Hardware reference</span></div>
<div class="line">  DisplayMode current_mode_; <span class="comment">// Current display mode</span></div>
<div class="line">  <span class="keywordtype">bool</span> initialized_ = <span class="keyword">false</span>; <span class="comment">// Initialization state</span></div>
<div class="line">  <span class="keywordtype">bool</span> is_asleep_ = <span class="keyword">false</span>;   <span class="comment">// Sleep state (for transparent wake)</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md148"></a>
State Transitions</h2>
<div class="fragment"><div class="line"><span class="comment">// Initialization</span></div>
<div class="line">init(mode) → initialized_ = <span class="keyword">true</span>, is_asleep_ = <span class="keyword">false</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sleep</span></div>
<div class="line">sleep() → is_asleep_ = true (if not already)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wake</span></div>
<div class="line">wake() → is_asleep_ = false, re-init hardware</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Display (with transparent wake)</span></div>
<div class="line">display(buffer) → check is_asleep_, call wake() if needed, then transfer</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md149"></a>
Idempotent Operations</h2>
<p>Make sleep/wake idempotent (safe to call multiple times):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> YourDriver::sleep() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="keywordflow">if</span> (is_asleep_) {</div>
<div class="line">    <span class="keywordflow">return</span> {};  <span class="comment">// Already asleep, nothing to do</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send sleep command</span></div>
<div class="line">  send_command(DEEP_SLEEP);</div>
<div class="line">  is_asleep_ = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> YourDriver::wake() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="keywordflow">if</span> (!is_asleep_) {</div>
<div class="line">    <span class="keywordflow">return</span> {};  <span class="comment">// Already awake, nothing to do</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Re-initialize (or send wake command if supported)</span></div>
<div class="line">  <span class="keyword">auto</span> result = init(current_mode_);</div>
<div class="line">  <span class="keywordflow">if</span> (!result) {</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  is_asleep_ = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md150"></a>
Error Handling in Drivers</h1>
<h2><a class="anchor" id="autotoc_md151"></a>
When to Return Errors</h2>
<p>Return <code>std::unexpected(Error{...})</code> for:</p><ul>
<li>Hardware communication failures</li>
<li>Timeouts (e.g., BUSY pin stuck HIGH)</li>
<li>Invalid state (e.g., <code>display()</code> called before <code>init()</code>)</li>
<li>Unsupported operations</li>
</ul>
<h2><a class="anchor" id="autotoc_md152"></a>
Error Codes to Use</h2>
<div class="fragment"><div class="line"><span class="comment">// Initialization errors</span></div>
<div class="line"><span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::DriverInitFailed,</div>
<div class="line">                             <span class="stringliteral">&quot;Hardware not responding&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// State errors</span></div>
<div class="line"><span class="keywordflow">if</span> (!initialized_) {</div>
<div class="line">  <span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::DriverNotInitialized,</div>
<div class="line">                               <span class="stringliteral">&quot;Call init() first&quot;</span>});</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hardware errors</span></div>
<div class="line"><span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::HardwareTimeout,</div>
<div class="line">                             <span class="stringliteral">&quot;BUSY pin timeout after 5 seconds&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Unsupported features</span></div>
<div class="line"><span class="keywordflow">return</span> std::unexpected(Error{ErrorCode::UnsupportedOperation,</div>
<div class="line">                             <span class="stringliteral">&quot;Partial refresh not supported&quot;</span>});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md153"></a>
Error Propagation</h2>
<p>Use <code>std::expected</code> chaining:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> YourDriver::some_operation() -&gt; std::expected&lt;void, Error&gt; {</div>
<div class="line">  <span class="keyword">auto</span> result = sub_operation();</div>
<div class="line">  <span class="keywordflow">if</span> (!result) {</div>
<div class="line">    <span class="keywordflow">return</span> result;  <span class="comment">// Propagate error</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Continue with success path</span></div>
<div class="line">  <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md154"></a>
Testing Your Driver</h1>
<h2><a class="anchor" id="autotoc_md155"></a>
Test Categories</h2>
<p><b>1. Basic Initialization:</b> </p><div class="fragment"><div class="line">TEST(YourDriverTest, InitializeSuccessfully) {</div>
<div class="line">  MockDevice device;</div>
<div class="line">  YourDriver driver(device);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> result = driver.init(DisplayMode::BlackWhite);</div>
<div class="line">  EXPECT_TRUE(result.has_value());</div>
<div class="line">  EXPECT_EQ(driver.width(), EXPECTED_WIDTH);</div>
<div class="line">  EXPECT_EQ(driver.height(), EXPECTED_HEIGHT);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. Display Modes:</b> </p><div class="fragment"><div class="line">TEST(YourDriverTest, SupportsBothModes) {</div>
<div class="line">  MockDevice device;</div>
<div class="line">  YourDriver driver(device);</div>
<div class="line"> </div>
<div class="line">  EXPECT_TRUE(driver.init(DisplayMode::BlackWhite).has_value());</div>
<div class="line">  EXPECT_TRUE(driver.init(DisplayMode::Grayscale4).has_value());</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>3. Sleep/Wake Cycles:</b> </p><div class="fragment"><div class="line">TEST(YourDriverTest, TransparentWakeWorks) {</div>
<div class="line">  MockDevice device;</div>
<div class="line">  YourDriver driver(device);</div>
<div class="line">  driver.init(DisplayMode::BlackWhite);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::byte&gt; buffer(driver.buffer_size(), std::byte{0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// First display</span></div>
<div class="line">  EXPECT_TRUE(driver.display(buffer).has_value());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Sleep</span></div>
<div class="line">  EXPECT_TRUE(driver.sleep().has_value());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Second display (should auto-wake)</span></div>
<div class="line">  EXPECT_TRUE(driver.display(buffer).has_value());</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>4. Error Conditions:</b> </p><div class="fragment"><div class="line">TEST(YourDriverTest, RejectsOperationsBeforeInit) {</div>
<div class="line">  MockDevice device;</div>
<div class="line">  YourDriver driver(device);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::byte&gt; buffer(1000);</div>
<div class="line">  <span class="keyword">auto</span> result = driver.display(buffer);</div>
<div class="line"> </div>
<div class="line">  EXPECT_FALSE(result.has_value());</div>
<div class="line">  EXPECT_EQ(result.error().code, ErrorCode::DriverNotInitialized);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md156"></a>
Hardware Testing Checklist</h2>
<p>Test with actual hardware:</p><ul>
<li>[ ] Initialization completes without errors</li>
<li>[ ] Display clears to white</li>
<li>[ ] Simple pattern (checkerboard) displays correctly</li>
<li>[ ] Text renders legibly</li>
<li>[ ] All four orientations work</li>
<li>[ ] Sleep/wake cycle works</li>
<li>[ ] Auto-sleep + transparent wake works</li>
<li>[ ] Multiple refresh cycles work</li>
<li>[ ] Both display modes work (B/W and grayscale)</li>
<li>[ ] No memory leaks over many cycles</li>
</ul>
<h1><a class="anchor" id="autotoc_md157"></a>
Optimization Tips</h1>
<h2><a class="anchor" id="autotoc_md158"></a>
SPI Transfer Optimization</h2>
<p><b>Batch Transfers:</b> </p><div class="fragment"><div class="line"><span class="comment">// Good: Single large transfer</span></div>
<div class="line">send_data(std::span&lt;const uint8_t&gt;{buffer.data(), buffer.size()});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: Many small transfers (slow!)</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">byte</span> : buffer) {</div>
<div class="line">  send_data(<span class="keywordtype">byte</span>);  <span class="comment">// Inefficient!</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Chunk Large Buffers:</b> </p><div class="fragment"><div class="line"><span class="comment">// For very large buffers, transfer in chunks</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> CHUNK_SIZE = 4096;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; buffer.size(); i += CHUNK_SIZE) {</div>
<div class="line">  <span class="keywordtype">size_t</span> chunk_size = std::min(CHUNK_SIZE, buffer.size() - i);</div>
<div class="line">  send_data(buffer.subspan(i, chunk_size));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md159"></a>
Memory Efficiency</h2>
<p><b>LUT Storage:</b> </p><div class="fragment"><div class="line"><span class="comment">// Good: Compile-time constant</span></div>
<div class="line"><span class="keyword">constexpr</span> std::array&lt;uint8_t, 30&gt; LUT = { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: Heap allocation</span></div>
<div class="line">std::vector&lt;uint8_t&gt; lut = { ... };  <span class="comment">// Unnecessary allocation</span></div>
</div><!-- fragment --><p><b>Buffer Reuse:</b> </p><div class="fragment"><div class="line"><span class="comment">// Good: Reuse internal buffers</span></div>
<div class="line"><span class="keyword">class </span>YourDriver {</div>
<div class="line">  std::vector&lt;uint8_t&gt; transfer_buffer_;  <span class="comment">// Reused for conversions</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: Allocate on every call</span></div>
<div class="line"><span class="keyword">auto</span> display(buffer) {</div>
<div class="line">  std::vector&lt;uint8_t&gt; temp(buffer.size());  <span class="comment">// Allocates every time!</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md160"></a>
Performance Profiling</h2>
<p>Profile critical sections:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line"><span class="comment">// ... operation ...</span></div>
<div class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::now();</div>
<div class="line"><span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Operation took &quot;</span> &lt;&lt; duration.count() &lt;&lt; <span class="stringliteral">&quot;ms\n&quot;</span>;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md161"></a>
Implementation Checklist</h1>
<p>Before submitting your driver:</p>
<h2><a class="anchor" id="autotoc_md162"></a>
Code Completeness</h2>
<ul>
<li>[ ] All pure virtual methods implemented</li>
<li>[ ] Header guards and proper includes</li>
<li>[ ] Namespace <code>epaper</code></li>
<li>[ ] Constants defined for all commands</li>
<li>[ ] Width/height constants match datasheet</li>
<li>[ ] Buffer size calculation correct</li>
</ul>
<h2><a class="anchor" id="autotoc_md163"></a>
State Management</h2>
<ul>
<li>[ ] <code>initialized_</code> flag used correctly</li>
<li>[ ] <code>is_asleep_</code> flag maintained</li>
<li>[ ] <code>current_mode_</code> tracked</li>
<li>[ ] Idempotent sleep/wake</li>
</ul>
<h2><a class="anchor" id="autotoc_md164"></a>
Transparent Sleep/Wake</h2>
<ul>
<li>[ ] <code>display()</code> checks <code>is_asleep_</code> and calls <code>wake()</code> if needed</li>
<li>[ ] <code>sleep()</code> sets <code>is_asleep_ = true</code></li>
<li>[ ] <code>wake()</code> clears <code>is_asleep_ = false</code></li>
<li>[ ] <code>init()</code> clears <code>is_asleep_ = false</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md165"></a>
Error Handling</h2>
<ul>
<li>[ ] All operations return <code>std::expected&lt;void, Error&gt;</code></li>
<li>[ ] Appropriate error codes used</li>
<li>[ ] Error messages are descriptive</li>
<li>[ ] Edge cases handled (null buffers, wrong size, etc.)</li>
</ul>
<h2><a class="anchor" id="autotoc_md166"></a>
Testing</h2>
<ul>
<li>[ ] Unit tests pass</li>
<li>[ ] Hardware tests pass</li>
<li>[ ] Sleep/wake cycle tested</li>
<li>[ ] Both display modes tested</li>
<li>[ ] Multiple orientations tested</li>
</ul>
<h2><a class="anchor" id="autotoc_md167"></a>
Documentation</h2>
<ul>
<li>[ ] Header comments explain purpose</li>
<li>[ ] Public methods documented</li>
<li>[ ] Example usage provided</li>
<li>[ ] Added to README driver list</li>
</ul>
<h2><a class="anchor" id="autotoc_md168"></a>
Code Quality</h2>
<ul>
<li>[ ] Follows project code style (clang-format)</li>
<li>[ ] No compiler warnings</li>
<li>[ ] Const correctness</li>
<li>[ ] RAII for resources</li>
<li>[ ] No raw pointers</li>
</ul>
<h1><a class="anchor" id="autotoc_md169"></a>
Common Issues &amp; Solutions</h1>
<h2><a class="anchor" id="autotoc_md170"></a>
Display Not Responding</h2>
<p><b>Problem:</b> Display doesn't update or shows garbage.</p>
<p><b>Solutions:</b></p><ol type="1">
<li>Verify initialization sequence matches datasheet exactly</li>
<li>Check BUSY pin logic (HIGH vs LOW varies by display)</li>
<li>Ensure reset sequence has correct delays</li>
<li>Verify SPI transfer byte order (MSB vs LSB first)</li>
<li>Check DC pin toggling (command vs data)</li>
</ol>
<h2><a class="anchor" id="autotoc_md171"></a>
Slow Refresh</h2>
<p><b>Problem:</b> Display update takes too long.</p>
<p><b>Solutions:</b></p><ol type="1">
<li>Batch SPI transfers (don't send byte-by-byte)</li>
<li>Reduce LUT complexity if possible</li>
<li>Check for unnecessary delays in code</li>
<li>Profile to find bottlenecks</li>
<li>Remember: e-paper is inherently slow (~2s is normal)</li>
</ol>
<h2><a class="anchor" id="autotoc_md172"></a>
Sleep Not Working</h2>
<p><b>Problem:</b> Display doesn't sleep or wake.</p>
<p><b>Solutions:</b></p><ol type="1">
<li>Verify sleep command is correct for your hardware</li>
<li>Check if <code>is_asleep_</code> flag is being set/cleared correctly</li>
<li>Ensure <code>display()</code> checks <code>is_asleep_</code> and calls <code>wake()</code></li>
<li>Some displays need special wake sequence (not just re-init)</li>
<li>Consult datasheet for power-down requirements</li>
</ol>
<h2><a class="anchor" id="autotoc_md173"></a>
Grayscale Not Working</h2>
<p><b>Problem:</b> Only black and white appear, no grays.</p>
<p><b>Solutions:</b></p><ol type="1">
<li>Verify LUT is loaded correctly</li>
<li>Check LUT values match datasheet for grayscale mode</li>
<li>Ensure buffer encoding is correct (2 bits per pixel)</li>
<li>Some displays don't support grayscale - check capabilities</li>
<li>Test with simple grayscale pattern first</li>
</ol>
<h1><a class="anchor" id="autotoc_md174"></a>
Contributing Your Driver</h1>
<h2><a class="anchor" id="autotoc_md175"></a>
Pull Request Requirements</h2>
<p>When contributing a new driver:</p>
<ol type="1">
<li><b>Code:</b><ul>
<li>Header: <code>include/epaper/drivers/your_epd.hpp</code></li>
<li>Implementation: <code>src/drivers/your_epd.cpp</code></li>
<li>Follow existing naming conventions</li>
</ul>
</li>
<li><b>Tests:</b><ul>
<li>Unit tests: <code>tests/test_your_epd.cpp</code></li>
<li>Hardware validation log (if possible)</li>
</ul>
</li>
<li><b>Documentation:</b><ul>
<li>Update <code><a class="el" href="../../da/ddd/README_8md.html">README.md</a></code> with driver in "Supported Hardware" section</li>
<li>Add example usage in <code>examples/</code></li>
<li>Datasheet link or reference</li>
</ul>
</li>
<li><b>CMake Integration:</b><ul>
<li>Add to <code>src/CMakeLists.txt</code></li>
<li>Add test to <code>tests/CMakeLists.txt</code></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md176"></a>
Pull Request Template</h2>
<div class="fragment"><div class="line">## New Driver: EPD42 (4.2&quot; Display)</div>
<div class="line"> </div>
<div class="line">### Hardware Specifications</div>
<div class="line">- Display: Waveshare 4.2&quot; e-Paper</div>
<div class="line">- Resolution: 400×300 pixels</div>
<div class="line">- Modes: Black/White, 4-level Grayscale</div>
<div class="line">- Partial Refresh: No</div>
<div class="line">- Power Control: No</div>
<div class="line"> </div>
<div class="line">### Implementation Details</div>
<div class="line">- Initialization: 15-step sequence based on datasheet v2.1</div>
<div class="line">- Sleep: Deep sleep mode (command 0x10)</div>
<div class="line">- Wake: Full re-initialization required</div>
<div class="line">- Transparent wake: Implemented via `is_asleep_` flag</div>
<div class="line"> </div>
<div class="line">### Testing</div>
<div class="line">- [x] Unit tests pass</div>
<div class="line">- [x] Hardware tested on Raspberry Pi 4</div>
<div class="line">- [x] All orientations verified</div>
<div class="line">- [x] Both display modes verified</div>
<div class="line">- [x] Sleep/wake cycles verified</div>
<div class="line">- [x] Example program included</div>
<div class="line"> </div>
<div class="line">### Datasheet</div>
<div class="line">https://www.waveshare.com/wiki/4.2inch_e-Paper_Module</div>
<div class="line"> </div>
<div class="line">### Checklist</div>
<div class="line">- [x] Code follows project style</div>
<div class="line">- [x] All tests pass</div>
<div class="line">- [x] Documentation updated</div>
<div class="line">- [x] Example included</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md177"></a>
Maintenance Responsibilities</h2>
<p>As a driver contributor, you're expected to:</p><ul>
<li>Respond to issues related to your driver</li>
<li>Test driver with library updates</li>
<li>Update driver if API changes</li>
<li>Provide hardware support to users (within reason)</li>
</ul>
<hr  />
<p><b>For architecture details, see <a class="el" href="../../d4/d34/md_docs_2ARCHITECTURE.html">ARCHITECTURE.md</a>.</b> <b>For API usage, see <a class="el" href="../../d7/d15/md_docs_2API.html">API.md</a>.</b> <b>For examples, see examples/README.md.</b> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
